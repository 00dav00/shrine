<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Shrine::Plugins::Backgrounding</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Shrine::Plugins::Backgrounding
        </h1>
        <ol class='paths'>
          <li>
            <a target="docwin" href="../../../files/lib/shrine/plugins/backgrounding_rb.html">lib/shrine/plugins/backgrounding.rb</a>
          </li>
        </ol>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The backgrounding plugin enables you to remove processing/storing/deleting
            of files from record&#39;s lifecycle, and put them into background jobs.
            This is generally useful if you&#39;re doing processing and/or your store
            is something other than <a
            href="../Storage/FileSystem.html">Storage::FileSystem</a>.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">backgrounding</span>&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">DeleteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }</pre>
            
            <p>The <code>data</code> variable is a serializable hash containing all
            context needed for promotion/deletion. You then just need to declare
            <code>PromoteJob</code> and <code>DeleteJob</code>, and call
            <code>Shrine::Attacher.promote</code>/<code>Shrine::Attacher.delete</code>
            with the data hash:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">PromoteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">DeleteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Internally these methods will resolve all necessary objects, do the
            promotion/deletion, and in case of promotion update the record with the
            stored attachment. Concurrency issues, like record being deleted or
            attachment being changed, are handled automatically.</p>
            
            <p>The examples above used Sidekiq, but obviously you can just as well use any
            other backgrounding library. This setup will work globally for all
            uploaders.</p>
            
            <p>Both methods return the record (if it exists and the action didn&#39;t
            abort), so you can use it to do additional actions:</p>
            
            <pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-identifier">record</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-identifier">record</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">published</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">record</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Post</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can also write custom background jobs with <code>Attacher.dump</code>
            and <code>Attacher.load</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">after_commit</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">some_condition</span>&#x000A;      <span class="ruby-identifier">data</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">dump</span>(<span class="ruby-identifier">avatar_attacher</span>)&#x000A;      <span class="ruby-constant">SomethingJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">SomethingJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-identifier">attacher</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">load</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you&#39;re generating versions, and you want to process some versions in
            the foreground before kicking off a background job, you can use the
            <code>recache</code> plugin.</p>
          </div>
          <div id='context'>
          </div>
          <div id='class-list'>
            <h2>Classes and Modules</h2>
            <ol>
              <li><a target="docwin" href="Backgrounding/AttacherClassMethods.html">Shrine::Plugins::Backgrounding::AttacherClassMethods</a></li>
              <li><a target="docwin" href="Backgrounding/AttacherMethods.html">Shrine::Plugins::Backgrounding::AttacherMethods</a></li>
            </ol>
          </div>
          <div id='section'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
