<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>creating_storages.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>creating_storages.md
</h1>
<div class='paths'>
doc/creating_storages.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2018-03-11 17:24:03 +0100</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Creating+a+New+Storage">Creating a New Storage<span><a href="#label-Creating+a+New+Storage">&para;</a> <a href="#top">&uarr;</a></span></h1>

<h2 id="label-Essentials">Essentials<span><a href="#label-Essentials">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html">Shrine</a> ships with the FileSystem
and S3 storages, but it&#39;s also easy to create your own. A storage is a
class which needs to implement to the following methods:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)&#x000A;        <span class="ruby-comment"># uploads `io` to the location `id`, can accept upload options</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">url</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)&#x000A;        <span class="ruby-comment"># returns URL to the remote file, accepts options for customizing the URL</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">open</span>(<span class="ruby-identifier">id</span>)&#x000A;        <span class="ruby-comment"># returns the remote file as an IO-like object</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">exists?</span>(<span class="ruby-identifier">id</span>)&#x000A;        <span class="ruby-comment"># checks if the file exists on the storage</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">delete</span>(<span class="ruby-identifier">id</span>)&#x000A;        <span class="ruby-comment"># deletes the file from the storage</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Upload">Upload<span><a href="#label-Upload">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The job of <code>Storage#upload</code> is to upload the given IO object to
the storage. It&#39;s recommended to use <a
href="https://github.com/httprb/http">HTTP.rb</a> for uploading, as it
accepts any IO object that responds to <code>#read</code> (not just file
objects), and it streams the IO data directly to the socket, making it
suitable for large uploads.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;http&quot;</span>&#x000A;&#x000A;<span class="ruby-comment"># streaming raw upload</span>&#x000A;<span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post</span>(<span class="ruby-string">&quot;http://example.com/upload&quot;</span>, <span class="ruby-value">body:</span> <span class="ruby-identifier">io</span>)&#x000A;<span class="ruby-comment"># streaming multipart upload</span>&#x000A;<span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post</span>(<span class="ruby-string">&quot;http://example.com/upload&quot;</span>, <span class="ruby-value">form:</span> { <span class="ruby-value">file:</span> <span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">FormData</span><span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>) })</pre>

<p>It&#39;s good practice to test the storage with a <a
href="https://github.com/shrinerb/shrine-cloudinary/blob/ca587c580ea0762992a2df33fd590c9a1e534905/test/test_helper.rb#L20-L27">fake
IO</a> object which responds only to required methods, as not all received
IO objects will be file objects.</p>

<p>If your storage doesn&#39;t control which id the uploaded file will have,
you can modify the <code>id</code> variable before returning:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-identifier">id</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-identifier">actual_id</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Likewise, if you need to save some information into the metadata after
upload, you can modify the metadata hash:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">upload</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-value">shrine_metadata:</span> {}, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-identifier">shrine_metadata</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">returned_metadata</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Download">Download<span><a href="#label-Download">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../../classes/Shrine.html">Shrine</a> automatically downloads the
file to a Tempfile using <code>#open</code>. However, if you would like to
do custom downloading, you can define <code>#download</code> and <a
href="../../classes/Shrine.html">Shrine</a> will use that instead:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">download</span>(<span class="ruby-identifier">id</span>)&#x000A;        <span class="ruby-comment"># download the file to a Tempfile</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Presign">Presign<span><a href="#label-Presign">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If the storage service supports direct uploads, and requires fetching
additional information from the server, you can implement a
<code>#presign</code> method, which will be used by the
<code>presign_endpoint</code> plugin. The method should return an object
which responds to</p>
<ul><li>
<p><code>#url</code> – returns the URL to which the file should be uploaded to</p>
</li><li>
<p><code>#fields</code> – returns a <code>Hash</code> of request parameters
that should be used for the upload</p>
</li><li>
<p><code>#headers</code> – returns a <code>Hash</code> of request headers that
should be used for the upload (optional)</p>
</li></ul>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">presign</span>(<span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>)&#x000A;        <span class="ruby-comment"># returns an object which responds to #url and #presign</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Move">Move<span><a href="#label-Move">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If your storage can move files, you can add 2 additional methods, and they
will automatically get used by the <code>moving</code> plugin:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">move</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">upload_options</span>)&#x000A;        <span class="ruby-comment"># does the moving of the `io` to the location `id`</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">movable?</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">id</span>)&#x000A;        <span class="ruby-comment"># whether the given `io` is movable to the location `id`</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Clearing">Clearing<span><a href="#label-Clearing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>While this method is not used by <a
href="../../classes/Shrine.html">Shrine</a>, it is good to give users the
possibility to delete all files in a storage, and the conventional name for
this method is <code>#clear!</code>:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Strorage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">clear!</span>&#x000A;        <span class="ruby-comment"># deletes all files in the storage</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Update">Update<span><a href="#label-Update">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If your storage supports updating data of existing files (e.g. some
metadata), the convention is to create an <code>#update</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">Storage</span>&#x000A;    <span class="ruby-keyword">class</span> <span class="ruby-constant">MyStorage</span>&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;&#x000A;      <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>(<span class="ruby-identifier">id</span>, <span class="ruby-identifier">options</span> = {})&#x000A;        <span class="ruby-comment"># update data of the file</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-comment"># ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Linter">Linter<span><a href="#label-Linter">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To check that your storage implements all these methods correctly, you can
use <code>Shrine::Storage::Linter</code>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/linter&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">storage</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">MyStorage</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)&#x000A;<span class="ruby-identifier">linter</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Linter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">storage</span>)&#x000A;<span class="ruby-identifier">linter</span>.<span class="ruby-identifier">call</span></pre>

<p>The linter will test your methods with fake IO objects, and raise a
<code>Shrine::LintError</code> if any part of the contract isn&#39;t
satisfied.</p>

<p>If you want to specify the IO object to use for testing (e.g. you need the
IO to be an actual image), you can pass in a lambda which returns the IO
when called:</p>

<pre class="ruby"><span class="ruby-identifier">linter</span>.<span class="ruby-identifier">call</span>(<span class="ruby-operator">-&gt;</span>{<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;test/fixtures/image.jpg&quot;</span>)})</pre>

<p>If you don&#39;t want errors to be raised but rather only warnings, you can
pass <code>action: :warn</code> when initializing</p>

<pre class="ruby"><span class="ruby-identifier">linter</span> = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Linter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">storage</span>, <span class="ruby-value">action:</span> <span class="ruby-value">:warn</span>)</pre>

<p>Note that using the linter doesn&#39;t mean that you shouldn&#39;t write
any manual tests for your storage. There will likely be some edge cases
that won&#39;t be tested by the linter.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
