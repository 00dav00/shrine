<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>2.14.0.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>2.14.0.md
</h1>
<div class='paths'>
doc/release_notes/2.14.0.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2018-12-27 20:38:28 +0100</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h2 id="label-New+features">New features<span><a href="#label-New+features">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>Shrine::Storage::S3</code> now accepts a <code>:client</code> option
for specifying an AWS  SDK client object. This allows the user to configure
client-side encryption by  passing a
<code>Aws::S3::Encryption::Client</code> object:</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">client</span> = <span class="ruby-constant">Aws</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span><span class="ruby-operator">::</span><span class="ruby-constant">Encryption</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">kms_key_id:</span> <span class="ruby-string">&quot;alias/my-key&quot;</span>,&#x000A;  <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">client:</span> <span class="ruby-identifier">client</span>, <span class="ruby-value">bucket:</span> <span class="ruby-string">&quot;my-bucket&quot;</span>)</pre>
<ul><li>
<p>The metadata blocks in the <code>add_metadata</code> plugin now have
previous metadata  available to them in <code>context[:metadata]</code>
(thanks to @jrochkind).</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">add_metadata</span> <span class="ruby-value">:foo</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">context</span>[<span class="ruby-value">:metadata</span>] <span class="ruby-comment">#=&gt;</span>&#x000A;  <span class="ruby-comment"># {</span>&#x000A;  <span class="ruby-comment">#   &quot;filename&quot;  =&gt; &quot;nature.jpg&quot;,</span>&#x000A;  <span class="ruby-comment">#   &quot;size&quot;      =&gt; 123,</span>&#x000A;  <span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;image/jpeg&quot;</span>&#x000A;  <span class="ruby-comment"># }</span>&#x000A;&#x000A;  <span class="ruby-string">&quot;foo&quot;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">add_metadata</span> <span class="ruby-value">:bar</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">context</span>[<span class="ruby-value">:metadata</span>] <span class="ruby-comment">#=&gt;</span>&#x000A;  <span class="ruby-comment"># {</span>&#x000A;  <span class="ruby-comment">#   &quot;filename&quot;  =&gt; &quot;nature.jpg&quot;,</span>&#x000A;  <span class="ruby-comment">#   &quot;size&quot;      =&gt; 123,</span>&#x000A;  <span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;image/jpeg&quot;,</span>&#x000A;  <span class="ruby-comment">#   &quot;foo&quot;       =&gt; &quot;foo&quot;</span>&#x000A;  <span class="ruby-comment"># }</span>&#x000A;&#x000A;  <span class="ruby-string">&quot;bar&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
<ul><li>
<p><code>UploadedFile#to_rack_response</code> from <code>rack_response</code>
plugin now accepts  <code>:type</code> and <code>:filename</code> options
for overriding the values in metadata that  would otherwise be used for the
<code>Content-Type</code> and <code>Content-Disposition</code>  response
headers.</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">status</span>, <span class="ruby-identifier">headers</span>, <span class="ruby-identifier">body</span> = <span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">to_rack_response</span>(&#x000A;  <span class="ruby-value">type:</span>     <span class="ruby-string">&quot;text/csv; charset=utf-8&quot;</span>,&#x000A;  <span class="ruby-value">filename:</span> <span class="ruby-string">&quot;export.csv&quot;</span>,&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">headers</span>[<span class="ruby-string">&quot;Content-Type&quot;</span>]        <span class="ruby-comment">#=&gt; &quot;text/csv; charset=utf-8&quot;</span>&#x000A;<span class="ruby-identifier">headers</span>[<span class="ruby-string">&quot;Content-Disposition&quot;</span>] <span class="ruby-comment">#=&gt; &quot;inline; filename=\&quot;export.csv\&quot;&quot;</span></pre>
<ul><li>
<p><code>Shrine.data_uri</code> from <code>data_uri</code> plugin now accepts
a <code>:filename</code> string,  which will be returned in 
<code>Shrine::Plugins::DataUri::DataFile#original_filename</code>.</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">io</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">data_uri</span>(<span class="ruby-string">&quot;data:,content&quot;</span>, <span class="ruby-value">filename:</span> <span class="ruby-string">&quot;foo.txt&quot;</span>)&#x000A;<span class="ruby-identifier">io</span>.<span class="ruby-identifier">original_filename</span> <span class="ruby-comment">#=&gt; &quot;foo.txt&quot;</span></pre>
<ul><li>
<p><code>UploadedFile#download_url</code> from <code>download_endpoint</code>
plugin now accepts a  <code>:host</code> option. Previously it was only
possible to configure the URL host on  the plugin level.</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">download_url</span>(<span class="ruby-value">host:</span> <span class="ruby-string">&quot;https://example.com&quot;</span>)</pre>
<ul><li>
<p><code>Attacher#cached?</code> and <code>Attacher#stored?</code> now accept
an optional uploaded  file parameter, and return whether the given uploaded
file is uploaded to the  temporary or permanent storage of the attacher
(thanks to @jrochkind).</p>
</li></ul>

<h2 id="label-Performance+improvements">Performance improvements<span><a href="#label-Performance+improvements">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><code>UploadedFile#download</code> doesn&#39;t call
<code>Storage#download</code> anymore (only  <code>Storage#open</code>).
This improves performance when the uploaded file is  already opened, e.g.
when using <code>refresh_metadata</code> plugin and 
<code>Shrine.with_file</code> during metadata extraction. Instead of
performing  a new download request, <code>UploadedFile#download</code> will
in this case reuse the  already opened IO object.</p>
</li><li>
<p>Added <code>tempfile</code> plugin that makes it easier to avoid copying
the  <code>UploadedFile</code> to disk multiple times during promotion. For
example, in the  following code the uploaded file will be downloaded to
disk only once  instead of three times.</p>
</li></ul>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:tempfile</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:add_metadata</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:refresh_metadata</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">io</span>.<span class="ruby-identifier">open</span> <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">io</span>.<span class="ruby-identifier">refresh_metadata!</span>&#x000A;&#x000A;      <span class="ruby-identifier">processor</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">Vips</span>.<span class="ruby-identifier">source</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">tempfile</span>)&#x000A;      <span class="ruby-comment"># ... processing ...</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">add_metadata</span> <span class="ruby-value">:foo</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">with_file</span>(<span class="ruby-identifier">io</span>) { <span class="ruby-string">&quot;...&quot;</span> } <span class="ruby-keyword">unless</span> <span class="ruby-identifier">context</span>[<span class="ruby-value">:action</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:store</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">add_metadata</span> <span class="ruby-value">:bar</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">with_file</span>(<span class="ruby-identifier">io</span>) { <span class="ruby-string">&quot;...&quot;</span> } <span class="ruby-keyword">unless</span> <span class="ruby-identifier">context</span>[<span class="ruby-value">:action</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:store</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
<ul><li>
<p><code>UploadedFile#refresh_metadata!</code> from
<code>refresh_metadata</code> plugin now detects  when the uploaded file is
already opened and in that case doesn&#39;t re-open the  file. This makes
code like this faster:</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">refresh_metadata!</span> <span class="ruby-comment"># doesn&#39;t re-open the file anymore</span>&#x000A;<span class="ruby-keyword">end</span></pre>
<ul><li>
<p>The <code>rack_response</code> plugin now integrates with
<code>Rack::Sendfile</code> middleware  when
<code>Shrine::Storage::FileSystem</code> is used. It does so by making the
response  body respond to <code>#to_path</code>.</p>
</li><li>
<p><code>#&lt;name&gt;_attacher</code> doesn&#39;t look up the attachment
class every time it&#39;s  called with a new model instance anymore, making
it slightly faster (thanks  to @printercu).</p>
</li></ul>

<h2 id="label-Other+improvements">Other improvements<span><a href="#label-Other+improvements">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>The <code>lib/shrine.rb</code> file has been split into
<code>lib/shrine.rb</code>,  <code>lib/shrine/uploaded_file.rb</code>,
<code>lib/shrine/attacher.rb</code>, 
<code>lib/shrine/attachment.rb</code>, and
<code>lib/shrine/plugins.rb</code> (thanks to  @printercu).</p>
</li><li>
<p><code>Shrine::Storage::S3</code> and <code>rack_response</code> plugin now
use the  <a
href="https://github.com/shrinerb/content_disposition">content_disposition</a>
gem for generating correctly formatted  <code>Content-Disposition</code>
header values.</p>
</li><li>
<p>The <code>S3#download</code> and <code>S3#open</code> methods now work
correctly with server-side  encryption (as long as the necessary
<code>:sse_*</code> parameters are passed in).</p>
</li><li>
<p>Fixed <code>FileSystem#clear!</code> not working with symlinks (at least on
MRI).</p>
</li><li>
<p>Fixed <code>add_metadata</code> plugin overriding previously defined
metadata  blocks when loaded again.</p>
</li><li>
<p>Fixed <code>processing</code> plugin overriding previously defined
processing  blocks when loaded again.</p>
</li><li>
<p>Fixed <code>backgrounding</code> plugin erroring when temorary/permanent
storage is  declared in <code>Shrine::Attachment.new</code> and there are
no <code>:cache</code> or <code>:store</code>  storages defined.</p>
</li><li>
<p>Fixed <code>UploadedFile#extension</code> (and thus the tempfile in 
<code>UploadedFile#download</code>) including URL query parameters in the
file extension  when <code>Shrine::Storage::Url</code> is used
(<code>shrine-url</code> gem) with URLs that have  query parameters (thanks
to @jrochkind).</p>
</li><li>
<p>Fixed <code>backgrounding</code> plugin aborting promotion when cached file
metadata was  refreshed in the processing block and Active Record JSON
column was used.</p>
<ul><li>
<p><code>refresh_metadata</code> plugin now avoids mutating the uploaded file
data hash</p>
</li><li>
<p><code>backgrounding</code> plugin now continues promotion if cached file
metadata has changed</p>
</li></ul>
</li><li>
<p>The <code>Shrine.data_uri</code> method from the <code>data_uri</code>
plugin now picks up media  type parameters from the data URI and includes
them in  <code>Shrine::Plugins::DataUri::DataFile#content_type</code>.</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">io</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">data_uri</span>(<span class="ruby-string">&quot;data:text/plain;charset=utf-8,content&quot;</span>)&#x000A;<span class="ruby-identifier">io</span>.<span class="ruby-identifier">content_type</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># BEFORE: &quot;text/plain&quot;</span>&#x000A;<span class="ruby-comment"># AFTER:  &quot;text/plain;charset=utf-8&quot;</span></pre>
<ul><li>
<p>When fetching <code>mime_type</code> metadata value from
<code>io.content_type</code>, any media  type parameters are now stripped.
This means that if the user uploads a text  file with a
<code>Content-Type</code> of <code>text/plain; charset=utf-8</code>, the
<code>mime_type</code>  will now correctly be stored as
<code>text/plain</code>. This fixes any MIME type  validations that might
not have been passing due to additional media type  parameters.</p>
</li><li>
<p>When <code>determine_mime_type</code> plugin is loaded with the
<code>:default</code> analyzer,  a warning is not printed anymore.</p>
</li><li>
<p>When <code>Shrine::Storage::S3</code> is initialized with <code>bucket:&#x000A;nil</code>, an appropriate  error message is now raised.</p>
</li><li>
<p>The <code>:content_type</code> MIME type analyzer has been added to the 
<code>Shrine.mime_type_analyzers</code> hash in
<code>determine_mime_type</code> plugin (previously  known as
<code>:default</code>).</p>
</li></ul>

<h2 id="label-Documentation">Documentation<span><a href="#label-Documentation">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>The <a
href="https://shrinerb.com/rdoc/files/doc/retrieving_uploads_md.html">Retrieving
Uploads</a> guide has been added.</p>
</li></ul>

<h2 id="label-Backwards+compatibility">Backwards compatibility<span><a href="#label-Backwards+compatibility">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Support for MRI 2.1 and MRI 2.2 has been dropped.</p>
</li><li>
<p><code>Shrine::Plugins::Base</code> module has been removed and contained
modules have  been moved to <code>InstanceMethods</code> and
<code>ClassMethods</code> modules inside the  corresponding core classes.
This should not break anything unless you were  referencing those modules
directly.</p>
</li></ul>

<pre>Shrine::Plugins::Base::InstanceMethods        =&gt; Shrine::InstanceMethods&#x000A;Shrine::Plugins::Base::ClassMethods           =&gt; Shrine::ClassMethods&#x000A;Shrine::Plugins::Base::FileMethods            =&gt; Shrine::UploadedFile::InstanceMethods&#x000A;Shrine::Plugins::Base::FileClassMethods       =&gt; Shrine::UploadedFile::ClassMethods&#x000A;Shrine::Plugins::Base::AttacherMethods        =&gt; Shrine::Attacher::InstanceMethods&#x000A;Shrine::Plugins::Base::AttacherClassMethods   =&gt; Shrine::Attacher::ClassMethods&#x000A;Shrine::Plugins::Base::AttachmentMethods      =&gt; Shrine::Attachment::InstanceMethods&#x000A;Shrine::Plugins::Base::AttachmentClassMethods =&gt; Shrine::Attachment::ClassMethods</pre>
<ul><li>
<p><code>UploadedFile#download</code> doesn&#39;t call
<code>Storage#download</code> anymore, it now  always calls
<code>Storage#open</code>. Since <code>Storage#download</code> is not used
anywhere  else in <a href="../../../classes/Shrine.html">Shrine</a>,
storages can remove the <code>#download</code> method.</p>
</li><li>
<p><code>Shrine::Storage::S3#download</code> has been deprecated and will be
removed in  <a href="../../../classes/Shrine.html">Shrine</a> 3.</p>
</li><li>
<p>In <code>Shrine::Storage::S3#upload</code>, <code>#open</code>, and
<code>#presign</code> it&#39;s now deprecated  to pass the
<code>Content-Disposition</code> header value with non-ASCII characters. 
Starting with <a href="../../../classes/Shrine.html">Shrine</a> 3 these
characters won&#39;t be escaped anymore. You should  now use the <a
href="https://github.com/shrinerb/content_disposition">content_disposition</a>
gem to properly format the  <code>Content-Disposition</code> header value.</p>
</li></ul>

<pre class="ruby"><span class="ruby-comment"># BAD:</span>&#x000A;<span class="ruby-identifier">plugin</span> <span class="ruby-value">:default_url_options</span>, <span class="ruby-value">store:</span> <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">io</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>) <span class="ruby-keyword">do</span>&#x000A;  { <span class="ruby-value">response_content_disposition:</span> <span class="ruby-node">&quot;attachment; filename=\&quot;#{io.original_filename}\&quot;&quot;</span> }&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># GOOD:</span>&#x000A;<span class="ruby-identifier">plugin</span> <span class="ruby-value">:default_url_options</span>, <span class="ruby-value">store:</span> <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">io</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">options</span>) <span class="ruby-keyword">do</span>&#x000A;  { <span class="ruby-value">response_content_disposition:</span> <span class="ruby-constant">ContentDisposition</span>.<span class="ruby-identifier">attachment</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">original_filename</span>) }&#x000A;<span class="ruby-keyword">end</span></pre>
<ul><li>
<p>The <code>mime_type</code> metadata value will now strip any additional
media type  parameters such as <code>charset</code> from
<code>io.content_type</code>. If you were relying on  this behaviour, you
will need to update your code.</p>
</li><li>
<p>In <code>determine_mime_type</code> plugin, the <code>:default</code> MIME
type analyzer has been  renamed to <code>:content_type</code>. The
<code>:default</code> alias will stop being supported in  <a
href="../../../classes/Shrine.html">Shrine</a> 3.</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:determine_mime_type</span>, <span class="ruby-value">analyzer:</span> <span class="ruby-value">:default</span>&#x000A;<span class="ruby-comment"># should be changed to</span>&#x000A;<span class="ruby-identifier">plugin</span> <span class="ruby-value">:determine_mime_type</span>, <span class="ruby-value">analyzer:</span> <span class="ruby-value">:content_type</span></pre>
<ul><li>
<p>The <code>UploadedFile</code> private methods that were added by the
<code>rack_response</code>  plugin have now been moved to an internal class
(leaving only  <code>#to_rack_response</code>). If you&#39;ve are currently
overriding any of these private  methods, you&#39;ll need to update your
code.</p>
</li><li>
<p>The <code>UploadedFile</code> private methods that were added by the
<code>download_endpoint</code>  plugin have now been moved to an internal
class (leaving only  <code>#download_url</code>). If you&#39;ve are
currently overriding any of these private  methods, you&#39;ll need to
update your code.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
