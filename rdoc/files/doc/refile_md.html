<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>refile.md</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>refile.md</h1>
        <div class='paths'>
          doc/refile.md
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2016-04-15 01:32:34 +0200</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Shrine+for+Refile+Users"><a href="../../classes/Shrine.html">Shrine</a> for Refile Users<span><a href="#label-Shrine+for+Refile+Users">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p>This guide is aimed at helping Refile users transition to <a
            href="../../classes/Shrine.html">Shrine</a>. We will first generally
            mention what are the key differences, and afterwards we will give a
            complete reference of Refile&#39;s interface and note what is the
            equivalent in <a href="../../classes/Shrine.html">Shrine</a>.</p>
            
            <h2 id="label-Uploaders">Uploaders<span><a href="#label-Uploaders">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../../classes/Shrine.html">Shrine</a> has the concept of storages
            very similar to Refile&#39;s backends. However, while in Refile you usually
            work with storages directly, in <a
            href="../../classes/Shrine.html">Shrine</a> you use <em>uploaders</em>
            which act as wrappers around storages, and they are subclasses of
            <code>Shrine</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/file_system&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/s3&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;}</pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># uploading logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>While in Refile you configure attachments by passing options to
            <code>.attachment</code>, in <a href="../../classes/Shrine.html">Shrine</a>
            you define all your uploading logic inside uploaders, and then generate an
            attacment module with that uploader which is included into the model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">store_dimensions</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">determine_mime_type</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">keep_files</span>, <span class="ruby-identifier">destroyed</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[:<span class="ruby-identifier">avatar</span>] <span class="ruby-comment"># requires &quot;avatar_data&quot; column</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Unlike Refile which has just a few options of configuring attachments, <a
            href="../../classes/Shrine.html">Shrine</a> has a very rich arsenal of
            features via plugins, and allows you to share your uploading logic between
            uploaders through inheritance.</p>
            
            <h3 id="label-ORMs">ORMs<span><a href="#label-ORMs">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>In Refile you extend the model with an Attachment module specific to the
            ORM you&#39;re using. In <a href="../../classes/Shrine.html">Shrine</a> you
            load the appropriate ORM plugin:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">sequel</span> <span class="ruby-comment"># or :activerecord</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[:<span class="ruby-identifier">image</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>These integrations work much like Refile; on assignment the file is cached,
            and on saving the record file is moved from cache to store. <a
            href="../../classes/Shrine.html">Shrine</a> doesn&#39;t provide form
            helpers for Rails, because it&#39;s so easy to do it yourself:</p>
            
            <pre>&lt;%= form_for @photo do |f| %&gt;&#x000A;  &lt;%= f.hidden_field :image, value: @photo.image_data %&gt;&#x000A;  &lt;%= f.file_field :image %&gt;&#x000A;&lt;% end %&gt;</pre>
            
            <h3 id="label-URLs">URLs<span><a href="#label-URLs">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>To get file URLs, in <a href="../../classes/Shrine.html">Shrine</a> you
            just call <code>#url</code> on the file:</p>
            
            <pre class="ruby"><span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">url</span>&#x000A;<span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">image_url</span> <span class="ruby-comment"># returns nil if attachment is missing</span></pre>
            
            <p>If you&#39;re using storages which don&#39;t expose files over URL, or you
            want to secure your downloads, you can use the
            <code>download_endpoint</code> plugin.</p>
            
            <h3 id="label-Metadata">Metadata<span><a href="#label-Metadata">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>While in Refile you&#39;re required to have a separate column for each
            metadata you want to save (filename, size, content type), in <a
            href="../../classes/Shrine.html">Shrine</a> all of the metadata are stored
            in a single column (for “avatar” it&#39;s <code>avatar_data</code> column)
            as JSON.</p>
            
            <pre class="ruby"><span class="ruby-identifier">user</span>.<span class="ruby-identifier">avatar_data</span> <span class="ruby-comment">#=&gt; &quot;{\&quot;storage\&quot;:\&quot;cache\&quot;,\&quot;id\&quot;:\&quot;9260ea09d8effd.jpg\&quot;,\&quot;metadata\&quot;:{...}}&quot;</span></pre>
            
            <p>By default <a href="../../classes/Shrine.html">Shrine</a> stores
            “filename”, “size” and “mime_type” metadata, but you can also store image
            dimensions by loading the <code>store_dimensions</code> plugin.</p>
            
            <h3 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>One of the key differences between Refile and <a
            href="../../classes/Shrine.html">Shrine</a> is that in Refile you do
            processing on-the-fly (like Dragonfly), while in <a
            href="../../classes/Shrine.html">Shrine</a> you do your processing on
            upload (like CarrierWave and Paperclip). However, there are storages which
            you can use which support on-the-fly processing, like <a
            href="https://github.com/janko-m/shrine-cloudinary">shrine-cloudinary</a>
            or <a href="https://github.com/janko-m/shrine-imgix">shrine-imgix</a>.</p>
            
            <p>In <a href="../../classes/Shrine.html">Shrine</a> you do processing by
            overriding the <code>#process</code> method on your uploader (for images
            you can use the <a
            href="https://github.com/janko-m/image_processing">image_processing</a>
            gem):</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">process</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span>)&#x000A;    <span class="ruby-keyword">case</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">phase</span>]&#x000A;    <span class="ruby-keyword">when</span> :<span class="ruby-identifier">store</span>&#x000A;      <span class="ruby-identifier">resize_to_fit!</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>, <span class="ruby-value">700</span>, <span class="ruby-value">700</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Validations">Validations<span><a href="#label-Validations">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>While in Refile you can do extension, mime type and filesize validation by
            passing options to <code>.attachment</code>, in <a
            href="../../classes/Shrine.html">Shrine</a> you do this logic instance
            level, with the help of the <code>validation_helpers</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> [<span class="ruby-string">&quot;image/jpeg&quot;</span>, <span class="ruby-string">&quot;image/png&quot;</span>, <span class="ruby-string">&quot;image/gif&quot;</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Direct+uploads">Direct uploads<span><a href="#label-Direct+uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Shrine.html">Shrine</a> borrows Refile&#39;s idea of
            direct uploads, and ships with a <code>direct_upload</code> plugin which
            provides the endpoint that you can mount:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">direct_upload</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-comment"># config/routes.rb</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadEndpoint</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/attachments/images&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-comment"># POST /attachments/images/cache/upload</span>&#x000A;{&#x000A;  <span class="ruby-string">&quot;id&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;43kewit94.jpg&quot;</span>,&#x000A;  <span class="ruby-string">&quot;storage&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;cache&quot;</span>,&#x000A;  <span class="ruby-string">&quot;metadata&quot;</span><span class="ruby-operator">:</span> {&#x000A;    <span class="ruby-string">&quot;size&quot;</span><span class="ruby-operator">:</span> <span class="ruby-value">384393</span>,&#x000A;    <span class="ruby-string">&quot;filename&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;nature.jpg&quot;</span>,&#x000A;    <span class="ruby-string">&quot;mime_type&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;image/jpeg&quot;</span>&#x000A;  }&#x000A;}</pre>
            
            <p>Unlike Refile, <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
            ship with a JavaScript script which you can just include to make it work.
            Instead, you&#39;re expected to use one of the many excellent JavaScript
            libraries for generic file uploads, for example <a
            href="https://github.com/blueimp/jQuery-File-Upload">jQuery-File-Upload</a>.</p>
            
            <h4 id="label-Presigned+S3+uploads">Presigned S3 uploads<span><a href="#label-Presigned+S3+uploads">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>The <code>direct_upload</code> plugin also provides an endpoint for getting
            S3 presigns, you just need to pass the <code>presign: true</code> option.
            In the same way as with regular direct uploads, you can use a generic
            JavaScript file upload library. For the details read the <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">Direct Uploads
            to S3</a> guide.</p>
            
            <h3 id="label-Multiple+uploads">Multiple uploads<span><a href="#label-Multiple+uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t have a built-in
            solution for accepting multiple uploads, but it&#39;s actually very easy to
            do manually, see the <a
            href="https://github.com/janko-m/shrine-example">example app</a> on how you
            can do multiple uploads directly to S3.</p>
            
            <h2 id="label-Migrating+from+Refile">Migrating from Refile<span><a href="#label-Migrating+from+Refile">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>You have an existing app using Refile and you want to transfer it to <a
            href="../../classes/Shrine.html">Shrine</a>. Let&#39;s assume we have a
            <code>Photo</code> model with the “image” attachment. First we need to
            create the <code>image_data</code> column for Shrine:</p>
            
            <pre class="ruby"><span class="ruby-identifier">add_column</span> :<span class="ruby-identifier">photos</span>, :<span class="ruby-identifier">image_data</span>, :<span class="ruby-identifier">text</span></pre>
            
            <p>Afterwards we need to make new uploads write to the <code>image_data</code>
            column. This can be done by including the below module to all models that
            have Refile attachments:</p>
            
            <pre class="ruby"><span class="ruby-keyword">module</span> <span class="ruby-constant">RefileShrineSynchronization</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">write_shrine_data</span>(<span class="ruby-identifier">name</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">read_attribute</span>(<span class="ruby-node">&quot;#{name}_id&quot;</span>).<span class="ruby-identifier">present?</span>&#x000A;      <span class="ruby-identifier">data</span> = {&#x000A;        <span class="ruby-identifier">storage</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">store</span>,&#x000A;        <span class="ruby-identifier">id</span><span class="ruby-operator">:</span> <span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_id&quot;</span>),&#x000A;        <span class="ruby-identifier">metadata</span><span class="ruby-operator">:</span> {&#x000A;          <span class="ruby-identifier">size</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_size&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_size&quot;</span>)),&#x000A;          <span class="ruby-identifier">filename</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_filename&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_filename&quot;</span>)),&#x000A;          <span class="ruby-identifier">mime_type</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">send</span>(<span class="ruby-node">&quot;#{name}_content_type&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">respond_to?</span>(<span class="ruby-node">&quot;#{name}_content_type&quot;</span>)),&#x000A;        }&#x000A;      }&#x000A;&#x000A;      <span class="ruby-identifier">write_attribute</span>(:<span class="ruby-node">&quot;#{name}_data&quot;</span>, <span class="ruby-identifier">data</span>.<span class="ruby-identifier">to_json</span>)&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-identifier">write_attribute</span>(:<span class="ruby-node">&quot;#{name}_data&quot;</span>, <span class="ruby-keyword">nil</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">ActiveRecord</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span>&#x000A;  <span class="ruby-identifier">attachment</span> :<span class="ruby-identifier">image</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">RefileShrineSynchronization</span>&#x000A;&#x000A;  <span class="ruby-identifier">before_save</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">write_shrine_data</span>(:<span class="ruby-identifier">image</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">changes</span>.<span class="ruby-identifier">key?</span>(:<span class="ruby-identifier">image_id</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>After you deploy this code, the <code>image_data</code> column should now
            be successfully synchronized with new attachments. Next step is to run a
            script which writes all existing Refile attachments to
            <code>image_data</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Photo</span>.<span class="ruby-identifier">find_each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">photo</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">photo</span>.<span class="ruby-identifier">write_shrine_data</span>(:<span class="ruby-identifier">image</span>)&#x000A;  <span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save!</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Now you should be able to rewrite your application so that it uses <a
            href="../../classes/Shrine.html">Shrine</a> instead of Refile, using
            equivalent <a href="../../classes/Shrine.html">Shrine</a> storages. For
            help with translating the code from Refile to <a
            href="../../classes/Shrine.html">Shrine</a>, you can consult the reference
            below.</p>
            
            <h2 id="label-Refile+to+Shrine+direct+mapping">Refile to <a href="../../classes/Shrine.html">Shrine</a> direct mapping<span><a href="#label-Refile+to+Shrine+direct+mapping">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <h3 id="label-Refile"><code>Refile</code><span><a href="#label-Refile">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <h4 id="label-.cache-2C+.store-2C+.backends"><code>.cache</code>, <code>.store</code>, <code>.backends</code><span><a href="#label-.cache-2C+.store-2C+.backends">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p><a href="../../classes/Shrine.html">Shrine</a> calles these “storages”, and
            it doesn&#39;t have special accessors for <code>:cache</code> and
            <code>:store</code>:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Bar</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>),&#x000A;}</pre>
            
            <h4 id="label-.app-2C+.mount_point-2C+.automount"><code>.app</code>, <code>.mount_point</code>, <code>.automount</code><span><a href="#label-.app-2C+.mount_point-2C+.automount">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>The <code>direct_upload</code> plugin provides a subset of Refile&#39;s
            app&#39;s functionality, and you have to mount it in your framework&#39;s
            router:</p>
            
            <pre class="ruby"><span class="ruby-comment"># config/routes.rb</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># adds `POST /attachments/images/:storage/:name`</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadEndpoint</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/attachments/images&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-.allow_uploads_to"><code>.allow_uploads_to</code><span><a href="#label-.allow_uploads_to">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">direct_upload</span>, <span class="ruby-identifier">storages</span><span class="ruby-operator">:</span> [:<span class="ruby-identifier">cache</span>]</pre>
            
            <h4 id="label-.logger"><code>.logger</code><span><a href="#label-.logger">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">logging</span></pre>
            
            <h4 id="label-.processors-2C+.processor"><code>.processors</code>, <code>.processor</code><span><a href="#label-.processors-2C+.processor">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>In <a href="../../classes/Shrine.html">Shrine</a> processing is done by
            overriding the <code>#process</code> method in your uploader:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">process</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span>)&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-.types"><code>.types</code><span><a href="#label-.types">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>In <a href="../../classes/Shrine.html">Shrine</a> validations are done by
            calling <code>.validate</code> on the attacher class:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">MyUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">5</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-.extract_filename-2C+.extract_content_type"><code>.extract_filename</code>, <code>.extract_content_type</code><span><a href="#label-.extract_filename-2C+.extract_content_type">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>In <a href="../../classes/Shrine.html">Shrine</a> equivalents are (private)
            methods <code>Shrine#extract_filename</code> and
            <code>Shrine#extract_mime_type</code>.</p>
            
            <h4 id="label-.app_url"><code>.app_url</code><span><a href="#label-.app_url">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>You should use your framework to generate the URL to your mounted direct
            enpdoint.</p>
            
            <h4 id="label-.attachment_url-2C+.file_url"><code>.attachment_url</code>, <code>.file_url</code><span><a href="#label-.attachment_url-2C+.file_url">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>You can call <code>#url</code> on the uploaded file, or
            <code>#&lt;name&gt;_url</code> on the model. Additionally you can use the
            <code>download_endpoint</code> plugin.</p>
            
            <h4 id="label-.upload_url-2C+.attachment_upload_url-2C+.presign_url-2C+.attachment_presign_url"><code>.upload_url</code>, <code>.attachment_upload_url</code>, <code>.presign_url</code>, <code>.attachment_presign_url</code><span><a href="#label-.upload_url-2C+.attachment_upload_url-2C+.presign_url-2C+.attachment_presign_url">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>These should be generated directly by you, it depends on where you&#39;ve
            mounted the direct endpoint.</p>
            
            <h4 id="label-.host-2C+.cdn_host-2C+.app_host-2C+.allow_downloads_from-2C+allow_origin-2C+.content_max_age"><code>.host</code>, <code>.cdn_host</code>, <code>.app_host</code>, <code>.allow_downloads_from</code>, <code>allow_origin</code>, <code>.content_max_age</code><span><a href="#label-.host-2C+.cdn_host-2C+.app_host-2C+.allow_downloads_from-2C+allow_origin-2C+.content_max_age">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>Not needed since <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
            offer on-the-fly processing.</p>
            
            <h4 id="label-.secret_key-2C+.token-2C+.valid_token-3F"><code>.secret_key</code>, <code>.token</code>, <code>.valid_token?</code><span><a href="#label-.secret_key-2C+.token-2C+.valid_token-3F">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>Not needed since <a href="../../classes/Shrine.html">Shrine</a> doesn&#39;t
            offer on-the-fly processing.</p>
            
            <h3 id="label-attachment"><code>attachment</code><span><a href="#label-attachment">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Shrine&#39;s equivalent to calling the attachment is including an
            attachment module of an uploader:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">User</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[:<span class="ruby-identifier">avatar</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-3Aextension-2C+-3Acontent_type-2C+-3Atype"><code>:extension</code>, <code>:content_type</code>, <code>:type</code><span><a href="#label-3Aextension-2C+-3Acontent_type-2C+-3Atype">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>In <a href="../../classes/Shrine.html">Shrine</a> validations are done
            instance-level inside the uploader, most commonly with the
            <code>validation_helpers</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_extension_inclusion</span> [<span class="ruby-regexp">/jpe?g/</span>, <span class="ruby-string">&quot;png&quot;</span>]&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> [<span class="ruby-string">&quot;image/jpeg&quot;</span>, <span class="ruby-string">&quot;image/png&quot;</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-3Acache-2C+-3Astore"><code>:cache</code>, <code>:store</code><span><a href="#label-3Acache-2C+-3Astore">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p><a href="../../classes/Shrine.html">Shrine</a> provides a
            <code>default_storage</code> plugin for setting custom storages on the
            uploader:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">custom_cache</span>] = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Foo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">custom_store</span>] = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">Bar</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)</pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">default_storage</span>, <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">custom_cache</span>, <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">custom_store</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h4 id="label-3Araise_errors"><code>:raise_errors</code><span><a href="#label-3Araise_errors">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>No equivalent currently exists in <a
            href="../../classes/Shrine.html">Shrine</a>.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
