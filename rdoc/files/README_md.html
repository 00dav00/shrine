<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>README.md</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>README.md</h1>
        <div class='paths'>
          README.md
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2016-10-10 14:37:29 +0800</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Shrine"><a href="../classes/Shrine.html">Shrine</a><span><a href="#label-Shrine">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p><a href="../classes/Shrine.html">Shrine</a> is a toolkit for file
            attachments in Ruby applications.</p>
            
            <p>If you&#39;re not sure why you should care, you&#39;re encouraged to read
            the <a
            href="https://twin.github.io/better-file-uploads-with-shrine-motivation/">motivation
            behind creating Shrine</a>.</p>
            
            <h2 id="label-Resources">Resources<span><a href="#label-Resources">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Documentation: <a target="_top" href="http://shrinerb.com">shrinerb.com</a></p>
            </li><li>
            <p>Source: <a
            href="https://github.com/janko-m/shrine">github.com/janko-m/shrine</a></p>
            </li><li>
            <p>Bugs: <a
            href="https://github.com/janko-m/shrine/issues">github.com/janko-m/shrine/issues</a></p>
            </li><li>
            <p>Help &amp; Discussion: <a
            href="https://groups.google.com/forum/#!forum/ruby-shrine">groups.google.com/group/ruby-shrine</a></p>
            </li></ul>
            
            <h2 id="label-Quick+start">Quick start<span><a href="#label-Quick+start">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Add <a href="../classes/Shrine.html">Shrine</a> to the Gemfile and write an
            initializer which sets up the storage and loads the ORM plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;shrine&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/file_system&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;uploads/cache&quot;</span>), <span class="ruby-comment"># temporary</span>&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;uploads/store&quot;</span>), <span class="ruby-comment"># permanent</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">sequel</span> <span class="ruby-comment"># :activerecord</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">cached_attachment_data</span> <span class="ruby-comment"># for forms</span></pre>
            
            <p>Next decide how you will name the attachment attribute on your model, and
            run a migration that adds an <code>&lt;attachment&gt;_data</code> text
            column, which <a href="../classes/Shrine.html">Shrine</a> will use to store
            all information about the attachment:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>                           <span class="ruby-comment"># class AddImageDataToPhotos &lt; ActiveRecord::Migration</span>&#x000A;  <span class="ruby-identifier">change</span> <span class="ruby-keyword">do</span>                                   <span class="ruby-comment">#   def change</span>&#x000A;    <span class="ruby-identifier">add_column</span> :<span class="ruby-identifier">photos</span>, :<span class="ruby-identifier">image_data</span>, :<span class="ruby-identifier">text</span>    <span class="ruby-comment">#     add_column :photos, :image_data, :text</span>&#x000A;  <span class="ruby-keyword">end</span>                                         <span class="ruby-comment">#   end</span>&#x000A;<span class="ruby-keyword">end</span>                                           <span class="ruby-comment"># end</span></pre>
            
            <p>Now you can create an uploader class for the type of files you want to
            upload, and add the attachment attribute to your model which will accept
            files:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># plugins and uploading logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span> <span class="ruby-comment"># ActiveRecord::Base</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[:<span class="ruby-identifier">image</span>]&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Let&#39;s now add the form fields needed for attaching files. We need a
            file field for choosing files, and a hidden field for retaining the
            uploaded file in case of validation errors and <a
            href="#direct-uploads">direct uploads</a>. Note that the file field needs
            to go <em>after</em> the hidden field, so that attaching a new file can
            always override whatever is in the hidden field.</p>
            
            <pre>&lt;form action=&quot;/photos&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&#x000A;  &lt;input name=&quot;photo[image]&quot; type=&quot;hidden&quot; value=&quot;&lt;%= @photo.cached_image_data %&gt;&quot;&gt;&#x000A;  &lt;input name=&quot;photo[image]&quot; type=&quot;file&quot;&gt;&#x000A;&lt;/form&gt;&#x000A;&lt;!-- Rails: --&gt;&#x000A;&lt;%= form_for @photo do |f| %&gt;&#x000A;  &lt;%= f.hidden_field :image, value: @photo.cached_image_data %&gt;&#x000A;  &lt;%= f.file_field :image %&gt;&#x000A;&lt;% end %&gt;</pre>
            
            <p>Note the <code>enctype=&quot;multipart/form-data&quot;</code> HTML
            attribute, which is required for submitting files through the form. The
            Rails form builder will automatically generate it for you when you add a
            file field.</p>
            
            <p>Now in your router/controller the attachment request parameter can be
            assigned to the model like any other attribute. Note that for non-Rails
            apps you will need to load the <code>rack_file</code> plugin which handles
            Rack&#39;s uploaded file hash.</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> <span class="ruby-string">&quot;/photos&quot;</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">photo</span>])&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Finally, you can use the URL of the attached file to display it:</p>
            
            <pre>&lt;img src=&quot;&lt;%= @photo.image_url %&gt;&quot;&gt;</pre>
            
            <h2 id="label-Attachment">Attachment<span><a href="#label-Attachment">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>When we assign an IO object to the record, <a
            href="../classes/Shrine.html">Shrine</a> will upload it to the registered
            <code>:cache</code> storage, which acts as a temporary storage, and write
            the location, storage, and metadata of the uploaded file to a single
            <code>&lt;attachment&gt;_data</code> column:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;waterfall.jpg&quot;</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt; &#39;{&quot;storage&quot;:&quot;cache&quot;,&quot;id&quot;:&quot;9260ea09d8effd.jpg&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>  <span class="ruby-comment">#=&gt; &quot;/uploads/cache/9260ea09d8effd.jpg&quot;</span></pre>
            
            <p>The <a href="../classes/Shrine.html">Shrine</a> attachment module added the
            following methods to the <code>Photo</code> model:</p>
            <ul><li>
            <p><code>#image=</code> – caches the file and saves the result into
            <code>image_data</code></p>
            </li><li>
            <p><code>#image</code> – returns <code>Shrine::UploadedFile</code>
            instantiated from <code>image_data</code></p>
            </li><li>
            <p><code>#image_url</code> – calls <code>image.url</code> if attachment is
            present, otherwise returns nil</p>
            </li><li>
            <p><code>#image_attacher</code> – returns instance of
            <code>Shrine::Attacher</code> which handles attaching</p>
            </li></ul>
            
            <p>In addition to assigning new files, you can also assign already cached
            files using their JSON representation:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-string">&#39;{&#x000A;  &quot;storage&quot;: &quot;cache&quot;,&#x000A;  &quot;id&quot;: &quot;9260ea09d8effd.jpg&quot;,&#x000A;  &quot;metadata&quot;: { ... }&#x000A;}&#39;</span></pre>
            
            <p>This allows <a href="../classes/Shrine.html">Shrine</a> to retain uploaded
            files in case of validation errors, and handle <a
            href="#direct-uploads">direct uploads</a>, via the hidden form field.</p>
            
            <p>The ORM plugin that we loaded adds appropriate callbacks, so when record is
            saved the attachment is uploaded to permanent storge (<code>:store</code>),
            and when record is destroyed the attachment is destroyed as well:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;waterfall.jpg&quot;</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span> <span class="ruby-comment">#=&gt; &quot;/uploads/cache/0sdfllasfi842.jpg&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span> <span class="ruby-comment">#=&gt; &quot;/uploads/store/l02kladf8jlda.jpg&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">destroy</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">exists?</span> <span class="ruby-comment">#=&gt; false</span></pre>
            
            <p>The ORM plugin will also delete replaced attachments:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-identifier">new_file</span>) <span class="ruby-comment"># changes the attachment and deletes previous</span>&#x000A;<span class="ruby-comment"># or</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)      <span class="ruby-comment"># removes the attachment and deletes previous</span></pre>
            
            <p>In all these examples we used <code>image</code> as the name of the
            attachment, but we can create attachment modules for any kind of
            attachments:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># video attachment logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Movie</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">VideoUploader</span>[:<span class="ruby-identifier">video</span>] <span class="ruby-comment"># uses &quot;video_data&quot; column</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Attacher">Attacher<span><a href="#label-Attacher">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The model attachment interface under-the-hood just delegates to a
            <code>Shrine::Attacher</code> object. If whether you don&#39;t want to add
            additional methods to your model, prefer explicitness over callbacks, or
            use <a href="../classes/Shrine.html">Shrine</a> with custom models, you can
            use <code>Shrine::Attacher</code> directly:</p>
            
            <pre class="ruby"><span class="ruby-identifier">attacher</span> = <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, :<span class="ruby-identifier">image</span>) <span class="ruby-comment"># equivalent to `photo.image_attacher`</span>&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">cache</span> <span class="ruby-comment">#=&gt; #&lt;ImageUploader @storage_key=:cache&gt;</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">store</span> <span class="ruby-comment">#=&gt; #&lt;ImageUploader @storage_key=:store&gt;</span>&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># equivalent to `photo.image = file`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">get</span>          <span class="ruby-comment"># equivalent to `photo.image`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">url</span>          <span class="ruby-comment"># equivalent to `photo.image_url`</span>&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">finalize</span>     <span class="ruby-comment"># promotes cached file to store, deletes old attachment (after save callback)</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">destroy</span>      <span class="ruby-comment"># deletes attachment (after destory callback)</span></pre>
            
            <p>See <a target="_top" href="http://shrinerb.com/rdoc/files/doc/attacher_md.html">Using
            Attacher</a> guide for more details.</p>
            
            <h3 id="label-Multiple+files">Multiple files<span><a href="#label-Multiple+files">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Sometimes we want to allow users to upload multiple files at once. This can
            be achieved with by adding a <code>multiple</code> HTML attribute to the
            file field: <code>&lt;input type=&quot;file&quot; multiple&gt;</code>.</p>
            
            <p><a href="../classes/Shrine.html">Shrine</a> doesn&#39;t accept multiple
            files on single a attachment attribute, but you can instead attach each
            file to a separate database record, which is a much more flexible solution.</p>
            
            <p>The best way is to <a href="#direct-uploads">directly upload</a> selected
            files, and then send the data of uploaded files as nested attributes for
            associated records. Alternatively you can send all selected files at once,
            and then transform them into nested association attributes in the
            controller.</p>
            
            <h2 id="label-Uploader">Uploader<span><a href="#label-Uploader">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>“Uploaders” are subclasses of <code>Shrine</code>, and this is where we
            define all our attachment logic. Uploader objects act as a wrappers around
            a storage; they don&#39;t know anything about models, and are stateless.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># document uploading logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">DocumentUploader</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;resume.pdf&quot;</span>))&#x000A;<span class="ruby-identifier">uploaded_file</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">to_json</span> <span class="ruby-comment">#=&gt; &#39;{&quot;storage&quot;:&quot;store&quot;,&quot;id&quot;:&quot;0sdfllasfi842.pdf&quot;,&quot;metadata&quot;:{...}}&#39;</span></pre>
            
            <p>The <code>Shrine#upload</code> method does the following:</p>
            <ul><li>
            <p>calls processing</p>
            </li><li>
            <p>extracts metadata</p>
            </li><li>
            <p>generates unique location</p>
            </li><li>
            <p>uploads file(s) (this is where the storage is called)</p>
            </li><li>
            <p>closes uploaded file(s)</p>
            </li></ul>
            
            <p><a href="../classes/Shrine.html">Shrine</a> requires the input for
            uploading to be an IO-like object. So, <code>File</code>,
            <code>Tempfile</code> and <code>StringIO</code> instances are all valid
            inputs. The object doesn&#39;t have to be an actual IO, it&#39;s enough
            that it responds to: <code>#read(*args)</code>, <code>#size</code>,
            <code>#eof?</code>, <code>#rewind</code> and <code>#close</code>.
            <code>ActionDispatch::Http::UploadedFile</code> is one such object, as well
            as <code>Shrine::UploadedFile</code> itself.</p>
            
            <p>The result of uploading is a <code>Shrine::UploadedFile</code> object,
            which represents the uploaded file on the storage, and is defined by its
            underlying data hash.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">url</span>      <span class="ruby-comment">#=&gt; &quot;uploads/938kjsdf932.mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt; {...}</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">download</span> <span class="ruby-comment">#=&gt; #&lt;Tempfile:/var/folders/k7/6zx6dx6x7ys3rv3srh0nyfj00000gn/T/20151004-74201-1t2jacf.mp4&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">exists?</span>  <span class="ruby-comment">#=&gt; true</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">io</span><span class="ruby-operator">|</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read</span> }&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">delete</span>&#x000A;<span class="ruby-comment"># ...</span></pre>
            
            <p>This is the same object that is returned when we access the attachment
            through the record:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>
            
            <h3 id="label-Plugins">Plugins<span><a href="#label-Plugins">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../classes/Shrine.html">Shrine</a> comes with a small core which
            provides only the essential functionality, and any additional features are
            available via plugins. This way you can choose exactly what and how much <a
            href="../classes/Shrine.html">Shrine</a> does for you. See the <a
            href="http://shrinerb.com">website</a> for a complete list of plugins.</p>
            
            <p>The plugin system respects inheritance, so you can choose to load a plugin
            globally or only for a specific uploader.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">logging</span> <span class="ruby-comment"># enables logging for all uploaders</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">backup</span> <span class="ruby-comment"># stores backups only for this uploader and its descendants</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> allows you to perform file
            processing in functional style; you receive the original file as the input,
            and return processed files as the output.</p>
            
            <p>Processing can be performed whenever a file is uploaded. On attaching this
            happens twice; first the raw file is cached to temporary storage (“cache”
            action), then when the record is saved the cached file is “promoted” to
            permanent storage (“store” action). We generally want to process on the
            “store” action, because it happens after file validations and can be
            backgrounded.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Ok, now how do we do the actual processing? Well, <a
            href="../classes/Shrine.html">Shrine</a> actually doesn&#39;t ship with any
            file processing functionality, because that is a generic problem that
            belongs in separate libraries. If the type of files you&#39;re uploading
            are images, I created the <a
            href="https://github.com/janko-m/image_processing">image_processing</a> gem
            which you can use with Shrine:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>, <span class="ruby-value">700</span>, <span class="ruby-value">700</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Here the <code>io</code> is a cached <code>Shrine::UploadedFile</code>, so
            we need to download it to a <code>File</code>, since this is what
            image_processing gem recognizes.</p>
            
            <h3 id="label-Versions">Versions<span><a href="#label-Versions">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Sometimes we want to generate multiple files as the result of processing.
            If we&#39;re uploading images, we might want to store various thumbnails
            alongside the original image. If we&#39;re uploading videos, we might want
            to save a screenshot or transcode it into different formats.</p>
            
            <p>To save multiple files, we just need to load the <code>versions</code>
            plugin, and then in <code>#process</code> we can return a Hash of files:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">versions</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">size_700</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>, <span class="ruby-value">700</span>, <span class="ruby-value">700</span>)&#x000A;    <span class="ruby-identifier">size_500</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_700</span>,    <span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;    <span class="ruby-identifier">size_300</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_500</span>,    <span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;&#x000A;    {<span class="ruby-identifier">large</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_700</span>, <span class="ruby-identifier">medium</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_500</span>, <span class="ruby-identifier">small</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_300</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>By defining processing on instance-level <a
            href="../classes/Shrine.html">Shrine</a> gives you a lot of flexibility.
            You could choose the processing order which yields the best performance,
            even add parallelization, and when processing logic gets complex you could
            extract everything into a PORO class. It is recommended to load the
            <code>delete_raw</code> plugin so that processed files are automatically
            deleted after uploading.</p>
            
            <p>Each version will be saved to the attachment column, and the attachment
            getter will simply return a Hash of <code>Shrine::UploadedFile</code>
            objects:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt; {large: ..., medium: ..., small: ...}</span>&#x000A;&#x000A;<span class="ruby-comment"># With the store_dimensions plugin (requires fastimage gem)</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">large</span>].<span class="ruby-identifier">width</span>  <span class="ruby-comment">#=&gt; 700</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">medium</span>].<span class="ruby-identifier">width</span> <span class="ruby-comment">#=&gt; 500</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">small</span>].<span class="ruby-identifier">width</span>  <span class="ruby-comment">#=&gt; 300</span>&#x000A;&#x000A;<span class="ruby-comment"># The plugin expands this method to accept version names.</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>(:<span class="ruby-identifier">large</span>) <span class="ruby-comment">#=&gt; &quot;...&quot;</span></pre>
            
            <h3 id="label-Custom+processing">Custom processing<span><a href="#label-Custom+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Your processing tool doesn&#39;t have to be in any way designed for <a
            href="../classes/Shrine.html">Shrine</a> (<a
            href="https://github.com/janko-m/image_processing">image_processing</a> is
            a generic library), you only need to return processed files as IO objects,
            e.g. <code>File</code> objects. Here&#39;s an example of processing a video
            with <a href="https://github.com/streamio/streamio-ffmpeg">ffmpeg</a>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;streamio-ffmpeg&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">versions</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">mov</span>        = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>&#x000A;    <span class="ruby-identifier">video</span>      = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;video&quot;</span>, <span class="ruby-string">&quot;.mp4&quot;</span>], <span class="ruby-identifier">binmode</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)&#x000A;    <span class="ruby-identifier">screenshot</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;screenshot&quot;</span>, <span class="ruby-string">&quot;.jpg&quot;</span>], <span class="ruby-identifier">binmode</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)&#x000A;&#x000A;    <span class="ruby-identifier">movie</span> = <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">mov</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">transcode</span>(<span class="ruby-identifier">video</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">screenshot</span>(<span class="ruby-identifier">screenshot</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;    <span class="ruby-identifier">mov</span>.<span class="ruby-identifier">delete</span>&#x000A;&#x000A;    {<span class="ruby-identifier">video</span><span class="ruby-operator">:</span> <span class="ruby-identifier">video</span>, <span class="ruby-identifier">screenshot</span><span class="ruby-operator">:</span> <span class="ruby-identifier">screenshot</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-Triggering+processing">Triggering processing<span><a href="#label-Triggering+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Whenever a file is uploaded by the attacher, an additional
            <code>:action</code> parameter is added to the context, which holds a
            symbol name describing what the file was uploaded for. For example, for
            caching files <code>action: :cache</code> will be sent, for promoting
            <code>action: :store</code>, while for backing up attacher sends
            <code>action: :backup</code>.</p>
            
            <p>The argument to the <code>process</code> declaration is the name of that
            action. When uploading via the uploader, you can add <code>:action</code>
            option with the value of the processing block you want performed before
            uploading.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">action</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">store</span>) <span class="ruby-comment"># performs processing defined under &quot;:store&quot;</span></pre>
            
            <p>You can also define and call processing for a custom action:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">my_action</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span> <span class="ruby-identifier">special_processing</span>(<span class="ruby-identifier">io</span>) }&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">action</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">my_action</span>)</pre>
            
            <p>Finally, you can also call defined processing directly, without uploading
            the results, using <code>Shrine#process</code>.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">action</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">my_action</span>) <span class="ruby-comment"># returns processed files without uploading</span></pre>
            
            <h2 id="label-Context">Context<span><a href="#label-Context">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>You may have noticed the <code>context</code> variable floating around as
            the second argument for processing. This variable is present all the way
            from input file to uploaded file, and can contain useful information
            depending on the situation:</p>
            <ul><li>
            <p><code>context[:record]</code> – the model instance</p>
            </li><li>
            <p><code>context[:name]</code> – attachment name on the model</p>
            </li><li>
            <p><code>context[:action]</code> – identifier for the action being performed
            (<code>:cache</code>, <code>:store</code>, <code>:recache</code>,
            <code>:backup</code>, …)</p>
            </li><li>
            <p><code>context[:version]</code> – version name of the IO in the argument</p>
            </li><li>
            <p>…</p>
            </li></ul>
            
            <p>The <code>context</code> is useful for doing conditional processing,
            validation, generating location etc, and it is also used by some plugins
            internally.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">trim_video</span>(<span class="ruby-identifier">io</span>, <span class="ruby-value">300</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">record</span>].<span class="ruby-identifier">guest?</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The context is just a hash that is passed to the uploader methods. If
            you&#39;re using the uploader directly, you can pass the context directly:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, {<span class="ruby-identifier">foo</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;bar&quot;</span>}) <span class="ruby-comment"># passing context hash directly</span></pre>
            
            <h2 id="label-Metadata">Metadata<span><a href="#label-Metadata">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> automatically extracts and
            stores available file metadata:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-identifier">image</span>)&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &quot;filename&quot;  =&gt; &quot;nature.jpg&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;image/jpeg&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;size&quot;      =&gt; 345993,</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">original_filename</span> <span class="ruby-comment">#=&gt; &quot;nature.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">extension</span>         <span class="ruby-comment">#=&gt; &quot;jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">mime_type</span>         <span class="ruby-comment">#=&gt; &quot;image/jpeg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 345993</span></pre>
            
            <h3 id="label-MIME+type">MIME type<span><a href="#label-MIME+type">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>By default, “mime_type” is inherited from <code>#content_type</code> of the
            uploaded file, which is set from the “Content-Type” request header, which
            is determined by the browser solely based on the file extension. This means
            that by default Shrine&#39;s “mime_type” is <em>not</em> guaranteed to hold
            the actual MIME type of the file.</p>
            
            <p>To help with that <a href="../classes/Shrine.html">Shrine</a> provides the
            <code>determine_mime_type</code> plugin, which by default uses the UNIX <a
            href="http://linux.die.net/man/1/file">file</a> utility to determine the
            actual MIME type:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">determine_mime_type</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;image.jpg&quot;</span>, <span class="ruby-string">&quot;&lt;?php ... ?&gt;&quot;</span>) <span class="ruby-comment"># PHP file with a .jpg extension</span>&#x000A;<span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image.jpg&quot;</span>))&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">mime_type</span> <span class="ruby-comment">#=&gt; &quot;text/x-php&quot;</span></pre>
            
            <h3 id="label-Custom+metadata">Custom metadata<span><a href="#label-Custom+metadata">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>You can also extract and store completely custom metadata with the
            <code>add_metadata</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">add_metadata</span>&#x000A;&#x000A;  <span class="ruby-identifier">add_metadata</span> :<span class="ruby-identifier">exif</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-constant">MiniMagick</span><span class="ruby-operator">::</span><span class="ruby-constant">Image</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">path</span>).<span class="ruby-identifier">exif</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;exif&quot;</span>]&#x000A;<span class="ruby-comment"># or</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">exif</span></pre>
            
            <h2 id="label-Validation">Validation<span><a href="#label-Validation">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Validations are registered inside a <code>Attacher.validate</code> block,
            and you can load the <code>validation_helpers</code> plugin to get some
            convenient file validation methods:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">50</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>, <span class="ruby-identifier">message</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;is too large (max is 50 MB)&quot;</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> [<span class="ruby-string">&quot;video/mp4&quot;</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">trailer</span> = <span class="ruby-constant">Trailer</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">trailer</span>.<span class="ruby-identifier">video</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;matrix.mp4&quot;</span>)&#x000A;<span class="ruby-identifier">trailer</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment">#=&gt; false</span>&#x000A;<span class="ruby-identifier">trailer</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">to_hash</span> <span class="ruby-comment">#=&gt; {video: [&quot;is too large (max is 50 MB)&quot;]}</span></pre>
            
            <p>You can also do custom validations:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">errors</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;is longer than 5 minutes&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">get</span>.<span class="ruby-identifier">duration</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">300</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The <code>Attacher.validate</code> block is executed in context of a
            <code>Shrine::Attacher</code> instance:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-keyword">self</span>   <span class="ruby-comment">#=&gt; #&lt;Shrine::Attacher&gt;</span>&#x000A;&#x000A;    <span class="ruby-identifier">get</span>    <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;    <span class="ruby-identifier">record</span> <span class="ruby-comment"># the model instance</span>&#x000A;    <span class="ruby-identifier">errors</span> <span class="ruby-comment"># array of error messages for this file</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Locations">Locations<span><a href="#label-Locations">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Before <a href="../classes/Shrine.html">Shrine</a> uploads a file, it
            generates a random location for it. By default the hierarchy is flat, all
            files are stored in the root of the storage. If you want that each
            attachment has its own directory, you can load the
            <code>pretty_location</code> plugin:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">pretty_location</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;nature.jpg&quot;</span>))&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">id</span> <span class="ruby-comment">#=&gt; &quot;photo/34/image/34krtreds2df.jpg&quot;</span></pre>
            
            <p>If you want to generate locations on your own, you can override
            <code>Shrine#generate_location</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">generate_location</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span>)&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">record</span>]&#x000A;      <span class="ruby-node">&quot;#{context[:record].class}/#{super}&quot;</span>&#x000A;    <span class="ruby-keyword">else</span>&#x000A;      <span class="ruby-keyword">super</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Note that there should always be a random component in the location, so
            that dirty tracking is detected properly; you can use
            <code>Shrine#generate_uid</code>. Inside <code>#generate_location</code>
            you can access the extracted metadata through
            <code>context[:metadata]</code>.</p>
            
            <p>When using the uploader directly, it&#39;s possible to bypass
            <code>#generate_location</code> by passing a <code>:location</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">MyUploader</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">file</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;nature.jpg&quot;</span>)&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">location</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;some/specific/location.jpg&quot;</span>)</pre>
            
            <h2 id="label-Storage">Storage<span><a href="#label-Storage">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>“Storages” are objects which know how to manage files on a particular
            service. Other than <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/FileSystem.html">FileSystem</a>,
            <a href="../classes/Shrine.html">Shrine</a> also ships with Amazon <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html">S3</a>
            storage:</p>
            
            <pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;aws-sdk&quot;</span>, <span class="ruby-string">&quot;~&gt; 2.1&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/s3&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">store</span>] = <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-identifier">access_key_id</span><span class="ruby-operator">:</span>     <span class="ruby-string">&quot;&lt;ACCESS_KEY_ID&gt;&quot;</span>,      <span class="ruby-comment"># &quot;xyz&quot;</span>&#x000A;  <span class="ruby-identifier">secret_access_key</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;&lt;SECRET_ACCESS_KEY&gt;&quot;</span>,  <span class="ruby-comment"># &quot;abc&quot;</span>&#x000A;  <span class="ruby-identifier">region</span><span class="ruby-operator">:</span>            <span class="ruby-string">&quot;&lt;REGION&gt;&quot;</span>,             <span class="ruby-comment"># &quot;eu-west-1&quot;</span>&#x000A;  <span class="ruby-identifier">bucket</span><span class="ruby-operator">:</span>            <span class="ruby-string">&quot;&lt;BUCKET&gt;&quot;</span>,             <span class="ruby-comment"># &quot;my-bucket&quot;</span>&#x000A;)</pre>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image.png&quot;</span>))&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span> <span class="ruby-comment">#=&gt; &quot;/uploads/cache/j4k343ui12ls9.png&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span> <span class="ruby-comment">#=&gt; &quot;https://my-bucket.s3.amazonaws.com/0943sf8gfk13.png&quot;</span></pre>
            
            <p>Note that any options passed to <code>image_url</code> will be forwarded to
            the underlying storage, see the documentation of the storage that
            you&#39;re using for which URL options it supports.</p>
            
            <p>You can see the full documentation for <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/FileSystem.html">FileSystem</a>
            and <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html">S3</a>
            storages. There are also many other <a
            href="../classes/Shrine.html">Shrine</a> storages available, see <a
            href="http://shrinerb.com#external">External</a> section on the website.</p>
            
            <h3 id="label-Upload+options">Upload options<span><a href="#label-Upload+options">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Many storages accept additional upload options, which you can pass via the
            <code>upload_options</code> plugin, or manually when uploading:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">MyUploader</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">upload_options</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">acl</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;private&quot;</span>})</pre>
            
            <h3 id="label-Clearing+cache">Clearing cache<span><a href="#label-Clearing+cache">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>From time to time you&#39;ll want to clean your temporary storage from old
            files. Amazon S3 provides <a
            href="http://docs.aws.amazon.com/AmazonS3/latest/UG/lifecycle-configuration-bucket-no-versioning.html">a
            built-in solution</a>, and for FileSystem you can put something like this
            in your Rake task:</p>
            
            <pre class="ruby"><span class="ruby-identifier">file_system</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">cache</span>]&#x000A;<span class="ruby-identifier">file_system</span>.<span class="ruby-identifier">clear!</span>(<span class="ruby-identifier">older_than</span><span class="ruby-operator">:</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span><span class="ruby-operator">*</span><span class="ruby-value">24</span><span class="ruby-operator">*</span><span class="ruby-value">60</span><span class="ruby-operator">*</span><span class="ruby-value">60</span>) <span class="ruby-comment"># delete files older than 1 week</span></pre>
            
            <h2 id="label-Direct+uploads">Direct uploads<span><a href="#label-Direct+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> comes with a
            <code>direct_upload</code> plugin for asynchronous uploads to your app or
            an external service like Amazon S3. It provides a <a
            href="https://github.com/jeremyevans/roda">Roda</a> endpoint which you can
            mount in your app:</p>
            
            <pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;roda&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">direct_upload</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadEndpoint</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/images&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>This endpoint provides the following routes:</p>
            <ul><li>
            <p><code>POST /images/cache/upload</code> - for direct uploads to your app</p>
            </li><li>
            <p><code>GET /images/cache/presign</code> - for direct uploads to external
            service (e.g. Amazon S3)</p>
            </li></ul>
            
            <p>These routes can be used to asynchronously start caching the file the
            moment the user selects it, using JavaScript file upload libraries like <a
            href="https://github.com/blueimp/jQuery-File-Upload">jQuery-File-Upload</a>,
            <a href="https://github.com/enyo/dropzone">Dropzone</a> or <a
            href="https://github.com/FineUploader/fine-uploader">FineUploader</a>.</p>
            
            <p>See the <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Plugins/DirectUpload.html">direct_upload</a>
            plugin documentation and <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">Direct Uploads
            to S3</a> guide for more details, as well as the <a href="/demo">Roda</a>
            and <a
            href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a>
            demo apps which implement multiple uploads directly to S3.</p>
            
            <h2 id="label-Backgrounding">Backgrounding<span><a href="#label-Backgrounding">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> is the first file upload
            library designed for backgrounding support. Moving phases of managing file
            attachments to background jobs is essential for scaling and good user
            experience, and <a href="../classes/Shrine.html">Shrine</a> provides a
            <code>backgrounding</code> plugin which makes it really easy to plug in
            your favourite backgrounding library:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">backgrounding</span>&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">DeleteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }</pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">PromoteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DeleteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The above puts all promoting (uploading cached file to permanent storage)
            and deleting of files into a background Sidekiq job. Obviously instead of
            Sidekiq you can use <a
            href="https://github.com/janko-m/shrine/wiki/Backgrounding-libraries">any
            other backgrounding library</a>.</p>
            
            <p>The main advantages of Shrine&#39;s backgrounding support over other file
            upload libraries are:</p>
            <ul><li>
            <p><strong>User experience</strong> – After starting the background job, <a
            href="../classes/Shrine.html">Shrine</a> will save the  record with the
            cached attachment so that it can be immediately shown to the  user. With
            other file upload libraries users cannot see the file until the  background
            job has finished.</p>
            </li><li>
            <p><strong>Simplicity</strong> – Instead of writing the workers for you, <a
            href="../classes/Shrine.html">Shrine</a> allows you  to use your own
            workers in a very simple way. Also, no extra columns are  required.</p>
            </li><li>
            <p><strong>Generality</strong> – The above solution will automatically work
            for all uploaders,  types of files and models.</p>
            </li><li>
            <p><strong>Safety</strong> – All of Shrine&#39;s code has been designed to
            take delayed storing  into account, and concurrent requests are handled
            well.</p>
            </li></ul>
            
            <h2 id="label-On-the-fly+processing">On-the-fly processing<span><a href="#label-On-the-fly+processing">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> allows you to define processing
            that will be performed on upload. However, what if you want to have
            processing performed on-the-fly when the URL is requested? Unlike Refile or
            Dragonfly, <a href="../classes/Shrine.html">Shrine</a> doesn&#39;t come
            with an image server built in; instead it expects you to integrate any of
            the existing generic image servers.</p>
            
            <p><a href="../classes/Shrine.html">Shrine</a> has integrations for many
            commercial on-the-fly processing services, including <a
            href="https://github.com/janko-m/shrine-cloudinary">Cloudinary</a>, <a
            href="https://github.com/janko-m/shrine-imgix">Imgix</a> and <a
            href="https://github.com/janko-m/shrine-uploadcare">Uploadcare</a>.</p>
            
            <p>If you don&#39;t want to use a commercial service, <a
            href="https://github.com/choonkeat/attache">Attache</a> and <a
            href="http://markevans.github.io/dragonfly/">Dragonfly</a> are great
            open-source image servers. For Attache a <a
            href="../classes/Shrine.html">Shrine</a> integration is in progress, while
            for Dragonfly it is not needed.</p>
            
            <h2 id="label-Chunked+-26+Resumable+uploads">Chunked &amp; Resumable uploads<span><a href="#label-Chunked+-26+Resumable+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>When you&#39;re accepting large file uploads, you normally want to split it
            into multiple chunks. This way if an upload fails, it is just for one chunk
            and can be retried, while the previous chunks remain uploaded.</p>
            
            <p><a target="_top" href="http://tus.io">Tus</a> is an open protocol for resumable file
            uploads, which enables the client and the server to achieve reliable file
            uploads, even on unstable networks, with the possibility to resume the
            upload even after the browser is closed or the device shut down. You can
            use a client library like <a
            href="https://github.com/tus/tus-js-client">tus-js-client</a> to upload the
            file to <a
            href="https://github.com/janko-m/tus-ruby-server">tus-ruby-server</a>, and
            attach the uploaded file to a record using <a
            href="https://github.com/janko-m/shrine-url">shrine-url</a>. See <a
            href="https://github.com/janko-m/shrine-tus-demo">shrine-tus-demo</a> for
            an example integration.</p>
            
            <p>Another option might be to do chunked uploads directly to your storage
            service, if the storage service supports it (e.g. Amazon S3 or Google Cloud
            Storage).</p>
            
            <h2 id="label-Inspiration">Inspiration<span><a href="#label-Inspiration">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> was heavily inspired by <a
            href="https://github.com/refile/refile">Refile</a> and <a
            href="https://github.com/jeremyevans/roda">Roda</a>. From Refile it borrows
            the idea of “backends” (here named “storages”), attachment interface, and
            direct uploads. From Roda it borrows the implementation of an extensible <a
            href="http://twin.github.io/the-plugin-system-of-sequel-and-roda/">plugin
            system</a>.</p>
            
            <h2 id="label-Similar+libraries">Similar libraries<span><a href="#label-Similar+libraries">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Paperclip</p>
            </li><li>
            <p>CarrierWave</p>
            </li><li>
            <p>Dragonfly</p>
            </li><li>
            <p>Refile</p>
            </li></ul>
            
            <h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The gem is available as open source under the terms of the <a
            href="http://opensource.org/licenses/MIT">MIT License</a>.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
