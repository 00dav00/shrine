<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>README.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>README.md
</h1>
<div class='paths'>
README.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2018-08-21 20:45:00 +0200</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-Shrine"><a href="https://shrinerb.com">Shrine</a><span><a href="#label-Shrine">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/Shrine.html">Shrine</a> is a toolkit for file
attachments in Ruby applications. Some highlights:</p>
<ul><li>
<p><strong>Modular design</strong> – the <a
href="https://twin.github.io/the-plugin-system-of-sequel-and-roda/">plugin
system</a> allows you to load only the functionality you need</p>
</li><li>
<p><strong>Memory friendly</strong> – streaming uploads and downloads make it
work great with large files</p>
</li><li>
<p><strong>Cloud storage</strong> – store files on <a
href="https://shrinerb.com/rdoc/classes/Shrine/Storage/FileSystem.html">disk</a>,
<a href="https://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html">AWS
S3</a>, <a
href="https://github.com/renchap/shrine-google_cloud_storage">Google
Cloud</a>, <a
href="https://github.com/shrinerb/shrine-cloudinary">Cloudinary</a> and
others</p>
</li><li>
<p><strong>ORM integrations</strong> – works with <a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/Sequel.html">Sequel</a>,
<a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/Activerecord.html">ActiveRecord</a>,
<a href="https://github.com/katafrakt/hanami-shrine">Hanami::Model</a> and
<a href="https://github.com/shrinerb/shrine-mongoid">Mongoid</a></p>
</li><li>
<p><strong>Flexible processing</strong> – generate thumbnails with <a
href="https://www.imagemagick.org/script/index.php">ImageMagick</a> or <a
href="http://jcupitt.github.io/libvips/">libvips</a> using the <a
href="https://github.com/janko-m/image_processing">ImageProcessing</a> gem</p>
</li><li>
<p><strong>Metadata validation</strong> – <a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/ValidationHelpers.html">validate
files</a> based on <a
href="https://shrinerb.com/rdoc/files/doc/metadata_md.html">extracted
metadata</a></p>
</li><li>
<p><strong>Direct uploads</strong> – upload asynchronously <a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/UploadEndpoint.html">to
your app</a> or <a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/PresignEndpoint.html">to
the cloud</a> using <a href="https://uppy.io">Uppy</a></p>
</li><li>
<p><strong>Resumable uploads</strong> – make large file uploads <a
href="https://tus.io">resumable</a> by pointing <a
href="https://uppy.io/docs/tus/">Uppy</a> to a <a
href="https://github.com/janko-m/tus-ruby-server">resumable endpoint</a></p>
</li><li>
<p><strong>Background jobs</strong> – built-in support for <a
href="https://shrinerb.com/rdoc/classes/Shrine/Plugins/Backgrounding.html">background
processing</a> that supports <a
href="https://github.com/shrinerb/shrine/wiki/Backgrounding-libraries">any
backgrounding library</a></p>
</li></ul>

<p>If you&#39;re curious how it compares to other file attachment libraries,
see the <a
href="https://shrinerb.com/rdoc/files/doc/advantages_md.html">Advantages of
Shrine</a>.</p>

<h2 id="label-Resources">Resources<span><a href="#label-Resources">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Documentation: <a href="https://shrinerb.com">shrinerb.com</a></p>
</li><li>
<p>Demo code: <a
href="https://github.com/shrinerb/shrine/tree/master/demo">Roda</a> / <a
href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a></p>
</li><li>
<p>Source: <a
href="https://github.com/shrinerb/shrine">github.com/shrinerb/shrine</a></p>
</li><li>
<p>Bugs: <a
href="https://github.com/shrinerb/shrine/issues">github.com/shrinerb/shrine/issues</a></p>
</li><li>
<p>Help &amp; Discussion: <a
href="https://groups.google.com/forum/#!forum/ruby-shrine">groups.google.com/group/ruby-shrine</a></p>
</li></ul>

<h2 id="label-Quick+start">Quick start<span><a href="#label-Quick+start">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Add <a href="../classes/Shrine.html">Shrine</a> to the Gemfile and write an
initializer which sets up the storage and loads the ORM plugin:</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;shrine&quot;</span>, <span class="ruby-string">&quot;~&gt; 2.0&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/file_system&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-value">cache:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;uploads/cache&quot;</span>), <span class="ruby-comment"># temporary</span>&#x000A;  <span class="ruby-value">store:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;uploads&quot;</span>),       <span class="ruby-comment"># permanent</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:sequel</span> <span class="ruby-comment"># or :activerecord</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:cached_attachment_data</span> <span class="ruby-comment"># for retaining the cached file across form redisplays</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:restore_cached_data</span> <span class="ruby-comment"># re-extract metadata when attaching a cached file</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:rack_file</span> <span class="ruby-comment"># for non-Rails apps</span></pre>

<p>Next decide how you will name the attachment attribute on your model, and
run a migration that adds an <code>&lt;attachment&gt;_data</code> text or
JSON column, which <a href="../classes/Shrine.html">Shrine</a> will use to
store all information about the attachment:</p>

<pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>                           <span class="ruby-comment"># class AddImageDataToPhotos &lt; ActiveRecord::Migration</span>&#x000A;  <span class="ruby-identifier">change</span> <span class="ruby-keyword">do</span>                                   <span class="ruby-comment">#   def change</span>&#x000A;    <span class="ruby-identifier">add_column</span> <span class="ruby-value">:photos</span>, <span class="ruby-value">:image_data</span>, <span class="ruby-value">:text</span>    <span class="ruby-comment">#     add_column :photos, :image_data, :text</span>&#x000A;  <span class="ruby-keyword">end</span>                                         <span class="ruby-comment">#   end</span>&#x000A;<span class="ruby-keyword">end</span>                                           <span class="ruby-comment"># end</span></pre>

<p>Now you can create an uploader class for the type of files you want to
upload, and add a virtual attribute for handling attachments using this
uploader to your model:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># plugins and uploading logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span> <span class="ruby-comment"># ActiveRecord::Base</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:image</span>) <span class="ruby-comment"># adds an `image` virtual attribute</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Let&#39;s now add the form fields which will use this virtual attribute. We
need (1) a file field for choosing files, and (2) a hidden field for
retaining the uploaded file in case of validation errors and for potential
<a href="https://shrinerb.com/rdoc/files/doc/direct_s3_md.html">direct
uploads</a>.</p>

<pre class="ruby"><span class="ruby-comment"># with Forme:</span>&#x000A;<span class="ruby-identifier">form</span> <span class="ruby-ivar">@photo</span>, <span class="ruby-value">action:</span> <span class="ruby-string">&quot;/photos&quot;</span>, <span class="ruby-value">enctype:</span> <span class="ruby-string">&quot;multipart/form-data&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>, <span class="ruby-value">type:</span> <span class="ruby-value">:hidden</span>, <span class="ruby-value">value:</span> <span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">cached_image_data</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>, <span class="ruby-value">type:</span> <span class="ruby-value">:file</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span> <span class="ruby-string">&quot;Create&quot;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># with Rails form builder:</span>&#x000A;<span class="ruby-identifier">form_for</span> <span class="ruby-ivar">@photo</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">hidden_field</span> <span class="ruby-value">:image</span>, <span class="ruby-value">value:</span> <span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">cached_image_data</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">file_field</span> <span class="ruby-value">:image</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">submit</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># with Simple Form:</span>&#x000A;<span class="ruby-identifier">simple_form_for</span> <span class="ruby-ivar">@photo</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>, <span class="ruby-value">as:</span> <span class="ruby-value">:hidden</span>, <span class="ruby-value">input_html:</span> { <span class="ruby-value">value:</span> <span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">cached_image_data</span> }&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">input</span> <span class="ruby-value">:image</span>, <span class="ruby-value">as:</span> <span class="ruby-value">:file</span>&#x000A;  <span class="ruby-identifier">f</span>.<span class="ruby-identifier">button</span> <span class="ruby-value">:submit</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Note that the file field needs to go <em>after</em> the hidden field, so
that selecting a new file can always override the cached file in the hidden
field. Also notice the <code>enctype=&quot;multipart/form-data&quot;</code>
HTML attribute, which is required for submitting files through the form;
the Rails form builder will automatically generate this for you.</p>

<p>Now in your router/controller the attachment request parameter can be
assigned to the model like any other attribute:</p>

<pre class="ruby"><span class="ruby-identifier">post</span> <span class="ruby-string">&quot;/photos&quot;</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">:photo</span>])&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>Once a file is uploaded and attached to the record, you can retrieve a URL
to the uploaded file with <code>#&lt;attachment&gt;_url</code> and display
it on the page:</p>

<pre class="ruby"><span class="ruby-identifier">image_tag</span> <span class="ruby-ivar">@photo</span>.<span class="ruby-identifier">image_url</span></pre>

<h2 id="label-Storage">Storage<span><a href="#label-Storage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A “storage” in <a href="../classes/Shrine.html">Shrine</a> is an object
responsible for managing files on a specific storage service (disk, AWS S3,
Google Cloud etc), which implements a generic method interface. Storages
are configured directly and registered under a name in
<code>Shrine.storages</code>, so that they can later be used by uploaders.</p>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;aws-sdk-s3&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.2&quot;</span> <span class="ruby-comment"># for AWS S3 storage</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/s3&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">s3_options</span> = {&#x000A;  <span class="ruby-value">bucket:</span>            <span class="ruby-string">&quot;my-bucket&quot;</span>, <span class="ruby-comment"># required</span>&#x000A;  <span class="ruby-value">access_key_id:</span>     <span class="ruby-string">&quot;abc&quot;</span>,&#x000A;  <span class="ruby-value">secret_access_key:</span> <span class="ruby-string">&quot;xyz&quot;</span>,&#x000A;  <span class="ruby-value">region:</span>            <span class="ruby-string">&quot;my-region&quot;</span>,&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-value">cache:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;cache&quot;</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;  <span class="ruby-value">store:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;}</pre>

<p>The above example sets up AWS S3 storage both for temporary and permanent
storage, which is suitable for <a
href="https://shrinerb.com/rdoc/files/doc/direct_s3_md.html">direct
uploads</a>. The <code>:cache</code> and <code>:store</code> names are
special only in terms that the attacher will automatically pick them up,
but you can also register more storages under different names.</p>

<p><a href="../classes/Shrine.html">Shrine</a> ships with <a
href="https://shrinerb.com/rdoc/classes/Shrine/Storage/FileSystem.html">FileSystem</a>
and <a
href="https://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html">S3</a>
storage, take a look at their documentation for more details on various
features they support. There are <a
href="https://shrinerb.com/#external">many more Shrine storages</a>
provided by external gems, and you can also <a
href="https://shrinerb.com/rdoc/files/doc/creating_storages_md.html">create
your own storage</a>.</p>

<h2 id="label-Uploader">Uploader<span><a href="#label-Uploader">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Uploaders are subclasses of <code>Shrine</code>, and are essentially
wrappers around storages. They perform common tasks around upload that
aren&#39;t related to a particular storage.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># image attachent logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:store</span>)&#x000A;<span class="ruby-identifier">uploader</span> <span class="ruby-comment">#=&gt; uploader for storage registered under `:store`</span></pre>

<p>It&#39;s common to create an uploader for each type of file that you want
to handle (image, video, audio, document etc), but really you can organize
them in any way you like.</p>

<h3 id="label-Uploading">Uploading<span><a href="#label-Uploading">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The main method of the uploader is <code>#upload</code>, which takes an
IO-like object on the input, and returns a representation of the uploaded
file on the output.</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>)&#x000A;<span class="ruby-identifier">uploaded_file</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>

<p>Some of the tasks performed by <code>#upload</code> include:</p>
<ul><li>
<p>file processing (if defined)</p>
</li><li>
<p>extracting metadata</p>
</li><li>
<p>generating location</p>
</li><li>
<p>uploading (this is where the storage is called)</p>
</li><li>
<p>closing the uploaded file</p>
</li></ul>

<h3 id="label-IO+abstraction">IO abstraction<span><a href="#label-IO+abstraction">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="../classes/Shrine.html">Shrine</a> is able to upload any IO-like
object that responds to <code>#read</code>, <code>#rewind</code>,
<code>#eof?</code> and <code>#close</code>. This includes built-in IO and
IO-like objects like File, Tempfile and StringIO.</p>

<p>When a file is uploaded to a Rails app, it will be represented by an
ActionDispatch::Http::UploadedFile object in the params. This is also an
IO-like object accepted by <a href="../classes/Shrine.html">Shrine</a>. In
other Rack applications the uploaded file will be represented as a Hash,
but it can still be attached when <code>rack_file</code> plugin is loaded.</p>

<p>Here are some examples of IO objects that can be uploaded:</p>

<pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;/path/to/file&quot;</span>, <span class="ruby-string">&quot;rb&quot;</span>)             <span class="ruby-comment"># upload from disk</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;file content&quot;</span>)                 <span class="ruby-comment"># upload from memory</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">ActionDispatch</span><span class="ruby-operator">::</span><span class="ruby-constant">Http</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadedFile</span>.<span class="ruby-identifier">new</span>       <span class="ruby-comment"># upload from Rails controller</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">rack_file</span>({ <span class="ruby-value">tempfile:</span> <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span> }) <span class="ruby-comment"># upload from Rack controller</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">Rack</span><span class="ruby-operator">::</span><span class="ruby-constant">Test</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadedFile</span>.<span class="ruby-identifier">new</span>                 <span class="ruby-comment"># upload from rack-test</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span> <span class="ruby-constant">Down</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;https://example.org/file&quot;</span>)        <span class="ruby-comment"># upload from internet</span></pre>

<p><code>Shrine::UploadedFile</code>, the object returned after upload, is
itself an IO-like object as well. This makes it trivial to reupload a file
from one storage to another, and this is used by the attacher to reupload a
file stored on temporary storage to permanent storage.</p>

<h2 id="label-Uploaded+file">Uploaded file<span><a href="#label-Uploaded+file">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>Shrine::UploadedFile</code> object represents the file that was
uploaded to the storage, and it&#39;s what&#39;s returned from
<code>Shrine#upload</code> or when retrieving a record attachment. It
contains the following information:</p>
<ul><li>
<p><code>storage</code> – identifier of the storage the file was uploaded to</p>
</li><li>
<p><code>id</code> – location of the file on the storage</p>
</li><li>
<p><code>metadata</code> – file metadata that was extracted before upload</p>
</li></ul>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>)&#x000A;&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">id</span>       <span class="ruby-comment">#=&gt; &quot;949sdjg834.jpg&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">storage</span>  <span class="ruby-comment">#=&gt; #&lt;Shrine::Storage::FileSystem&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt; {...}</span>&#x000A;&#x000A;<span class="ruby-comment"># It can be serialized into JSON and saved to a database column</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">to_json</span>  <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;949sdjg834.jpg&quot;,&quot;storage&quot;:&quot;store&quot;,&quot;metadata&quot;:{...}}&#39;</span></pre>

<p>It comes with many convenient methods that delegate to the storage:</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">url</span>                 <span class="ruby-comment">#=&gt; &quot;https://my-bucket.s3.amazonaws.com/949sdjg834.jpg&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span>                <span class="ruby-comment"># opens the uploaded file</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">download</span>            <span class="ruby-comment">#=&gt; #&lt;File:/var/folders/.../20180302-33119-1h1vjbq.jpg&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">stream</span>(<span class="ruby-identifier">destination</span>) <span class="ruby-comment"># streams uploaded content into a writable destination</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">exists?</span>             <span class="ruby-comment">#=&gt; true</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">delete</span>              <span class="ruby-comment"># deletes the file from the storage</span>&#x000A;&#x000A;<span class="ruby-comment"># open/download the uploaded file for the duration of the block</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span>     { <span class="ruby-operator">|</span><span class="ruby-identifier">io</span><span class="ruby-operator">|</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read</span> }&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">download</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">tempfile</span><span class="ruby-operator">|</span> <span class="ruby-identifier">tempfile</span>.<span class="ruby-identifier">read</span> }</pre>

<p>It also implements the IO-like interface that conforms to Shrine&#39;s IO
abstraction, which allows it to be uploaded again to other storages.</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">read</span>   <span class="ruby-comment"># returns content of the uploaded file</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">eof?</span>   <span class="ruby-comment"># returns true if the whole IO was read</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">rewind</span> <span class="ruby-comment"># rewinds the IO</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">close</span>  <span class="ruby-comment"># closes the IO</span></pre>

<p>If you want to retrieve the content of the uploaded file, you can use a
combination of <code>#open</code> and <code>#read</code>:</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:read</span>) <span class="ruby-comment">#=&gt; &quot;...&quot; (binary content of the uploaded file)</span></pre>

<h2 id="label-Attachment">Attachment<span><a href="#label-Attachment">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Storages, uploaders, and uploaded file objects are the main components for
managing files. Since most often you also want to <em>attach</em> the
uploaded files to database records, <a
href="../classes/Shrine.html">Shrine</a> comes with a high-level attachment
interface, which uses these components internally.</p>

<p>Usually you&#39;re using an ORM for saving database records, in which case
you can load an additional plugin to automatically tie the attached files
to record lifecycle. But you can also use <a
href="../classes/Shrine.html">Shrine</a> just with plain models.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:sequel</span> <span class="ruby-comment"># :activerecord</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span> <span class="ruby-comment"># ActiveRecord::Base</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:image</span>) <span class="ruby-comment">#</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">attachment</span>(<span class="ruby-value">:image</span>)      <span class="ruby-comment"># these are all equivalent</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[<span class="ruby-value">:image</span>]                 <span class="ruby-comment">#</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>You can choose whichever of these three syntaxes you prefer. Either of
these will create a <code>Shrine::Attachment</code> module with attachment
methods for the specified attribute, which then get added to your model
when you include it:</p>
<ul><li>
<p><code>#image=</code> – uploads the file to temporary storage and serializes
the result into <code>image_data</code></p>
</li><li>
<p><code>#image</code> – returns <code>Shrine::UploadedFile</code>
instantiated from <code>image_data</code></p>
</li><li>
<p><code>#image_url</code> – calls <code>url</code> on the attachment if
it&#39;s present, otherwise returns nil</p>
</li><li>
<p><code>#image_attacher</code> – returns instance of
<code>Shrine::Attacher</code> which handles the attaching</p>
</li></ul>

<p>The ORM plugin that we loaded adds appropriate callbacks, so when record is
saved the attachment is uploaded to permanent storage, and when record is
deleted the attachment is deleted as well.</p>

<pre class="ruby"><span class="ruby-comment"># no file is attached</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt; nil</span>&#x000A;&#x000A;<span class="ruby-comment"># the assigned file is cached to temporary storage and written to `image_data` column</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;waterfall.jpg&quot;</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile @data={...}&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>  <span class="ruby-comment">#=&gt; &quot;/uploads/cache/0sdfllasfi842.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;0sdfllasfi842.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;&#x000A;<span class="ruby-comment"># the cached file is promoted to permanent storage and saved to `image_data` column</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile @data={...}&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>  <span class="ruby-comment">#=&gt; &quot;/uploads/store/l02kladf8jlda.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;l02kladf8jlda.jpg&quot;,&quot;storage&quot;:&quot;store&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;&#x000A;<span class="ruby-comment"># the attached file is deleted with the record</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">destroy</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">exists?</span> <span class="ruby-comment">#=&gt; false</span></pre>

<p>If there is already a file attached and a new file is attached, the
previous attachment will get deleted when the record gets saved.</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">image:</span> <span class="ruby-identifier">new_file</span>) <span class="ruby-comment"># changes the attachment and deletes previous</span>&#x000A;<span class="ruby-comment"># or</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">image:</span> <span class="ruby-keyword">nil</span>)      <span class="ruby-comment"># removes the attachment and deletes previous</span></pre>

<p>In addition to assigning raw files, you can also assign a JSON
representation of files that are already uploaded to the temporary storage.
This allows <a href="../classes/Shrine.html">Shrine</a> to retain cached
files in case of validation errors and handle [direct uploads] via the
hidden form field.</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-string">&#39;{&quot;id&quot;:&quot;9260ea09d8effd.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span></pre>

<h2 id="label-Attacher">Attacher<span><a href="#label-Attacher">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The model attachment attributes and callbacks just delegate the behaviour
to ther underlying <code>Shrine::Attacher</code> object.</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_attacher</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::Attacher&gt;</span></pre>

<p>The <code>Shrine::Attacher</code> object can be instantiated and used
directly:</p>

<pre class="ruby"><span class="ruby-identifier">attacher</span> = <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, <span class="ruby-value">:image</span>)&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># equivalent to `photo.image = file`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">get</span>          <span class="ruby-comment"># equivalent to `photo.image`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">url</span>          <span class="ruby-comment"># equivalent to `photo.image_url`</span></pre>

<p>The attacher is what drives attaching files to model instances, and it
functions independently from models&#39; attachment interface. This means
that you can use it as an alternative, in case you prefer not to add
additional attributes to the model, or prefer explicitness over callbacks.
It&#39;s also useful when you need something more advanced which isn&#39;t
available through the attachment attributes.</p>

<p>The <code>Shrine::Attacher</code> by default uses <code>:cache</code> for
temporary and <code>:store</code> for permanent storage, but you can
specify a different storage:</p>

<pre class="ruby"><span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, <span class="ruby-value">:image</span>, <span class="ruby-value">cache:</span> <span class="ruby-value">:other_cache</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:other_store</span>)&#x000A;&#x000A;<span class="ruby-comment"># OR</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_attacher</span>(<span class="ruby-value">cache:</span> <span class="ruby-value">:other_cache</span>, <span class="ruby-value">store:</span> <span class="ruby-value">:other_store</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-identifier">file</span> <span class="ruby-comment"># uploads to :other_cache storage</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>         <span class="ruby-comment"># promotes to :other_store storage</span></pre>

<p>Whenever the attacher uploads or deletes files, it sends a
<code>context</code> hash which includes <code>:record</code>,
<code>:name</code>, and <code>:action</code> keys, so that you can perform
processing or generate location differently depending on this information.
See “Context” section for more details.</p>

<p>For more information about <code>Shrine::Attacher</code>, see the <a
href="https://shrinerb.com/rdoc/files/doc/attacher_md.html">Using
Attacher</a> guide.</p>

<h2 id="label-Plugin+system">Plugin system<span><a href="#label-Plugin+system">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>By default <a href="../classes/Shrine.html">Shrine</a> comes with a small
core which provides only the essential functionality. All additional
features are available via <a
href="https://shrinerb.com/#plugins">plugins</a>, which also ship with <a
href="../classes/Shrine.html">Shrine</a>. This way you can choose exactly
what and how much <a href="../classes/Shrine.html">Shrine</a> does for you,
and you load the code only for features that you use.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:logging</span> <span class="ruby-comment"># adds logging</span></pre>

<p>Plugins add behaviour by extending <a
href="../classes/Shrine.html">Shrine</a> core classes via module inclusion,
and many of them also accept configuration options. The plugin system
respects inheritance, so you can choose to load a plugin globally or per
uploader.</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:store_dimensions</span> <span class="ruby-comment"># extract image dimensions only for this uploader and its descendants</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>If you want to extend <a href="../classes/Shrine.html">Shrine</a>
functionality with custom behaviour, you can also <a
href="https://shrinerb.com/rdoc/files/doc/creating_plugins_md.html">create
your own plugin</a>.</p>

<h2 id="label-Metadata">Metadata<span><a href="#label-Metadata">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> automatically extracts some
basic file metadata and saves them to the
<code>Shrine::UploadedFile</code>. You can access them through the
<code>#metadata</code> hash or via metadata methods:</p>

<pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &quot;filename&quot; =&gt; &quot;matrix.mp4&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;video/mp4&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;size&quot; =&gt; 345993,</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">original_filename</span> <span class="ruby-comment">#=&gt; &quot;matrix.mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">extension</span>         <span class="ruby-comment">#=&gt; &quot;mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">mime_type</span>         <span class="ruby-comment">#=&gt; &quot;video/mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 345993</span></pre>

<h3 id="label-MIME+type">MIME type<span><a href="#label-MIME+type">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>By default <code>mime_type</code> will be inherited from
<code>#content_type</code> attribute of the uploaded file, which is set
from the <code>Content-Type</code> request header. However, this header is
determined by the browser solely based on the file extension. This means
that by default Shrine&#39;s <code>mime_type</code> is <em>not
guaranteed</em> to hold the actual MIME type of the file.</p>

<p>To remedy that, you can load the <code>determine_mime_type</code> plugin,
which will make <a href="../classes/Shrine.html">Shrine</a> extract the
MIME type from <em>file content</em>.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:determine_mime_type</span></pre>

<pre class="ruby"><span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-value">image:</span> <span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;&lt;?php ... ?&gt;&quot;</span>))&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">mime_type</span> <span class="ruby-comment">#=&gt; &quot;text/x-php&quot;</span></pre>

<p>By the default the UNIX <a target="_top" href="http://linux.die.net/man/1/file">file</a>
utility is used to determine the MIME type, but you can also choose a
different analyzer – see the plugin documentation for more details.</p>

<h3 id="label-Custom+metadata">Custom metadata<span><a href="#label-Custom+metadata">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In addition to <code>size</code>, <code>filename</code>, and
<code>mime_type</code>, you can also extract image dimensions using the
<code>store_dimensions</code> plugin, as well as any custom metadata using
the <code>add_metadata</code> plugin. Check out the <a
href="https://shrinerb.com/rdoc/files/doc/metadata_md.html">Extracting
Metadata</a> guide for more details.</p>

<h2 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Shrine&#39;s <code>processing</code> plugin allows you to intercept when
the cached file is being uploaded to permanent storage, and do any file
processing your might want.</p>

<p>If you&#39;re uploading images, it&#39;s common to want to generate various
thumbnails. It&#39;s recommended to use the <strong><a
href="https://github.com/janko-m/image_processing">ImageProcessing</a></strong>
gem for this, which provides a convenient API over <a
href="https://www.imagemagick.org/script/index.php">ImageMagick</a> and <a
href="http://jcupitt.github.io/libvips/">libvips</a>. You also need to load
the <code>versions</code> plugin to be able to save multiple files.</p>

<pre>$ brew install imagemagick</pre>

<pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_processing&quot;</span>, <span class="ruby-string">&quot;~&gt; 1.0&quot;</span></pre>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:processing</span> <span class="ruby-comment"># allows hooking into promoting</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:versions</span>   <span class="ruby-comment"># enable Shrine to handle a hash of files</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:delete_raw</span> <span class="ruby-comment"># delete processed files after uploading</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">versions</span> = { <span class="ruby-value">original:</span> <span class="ruby-identifier">io</span> } <span class="ruby-comment"># retain original</span>&#x000A;&#x000A;    <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">original</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">pipeline</span> = <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>.<span class="ruby-identifier">source</span>(<span class="ruby-identifier">original</span>)&#x000A;&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:large</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">800</span>, <span class="ruby-value">800</span>)&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:medium</span>] = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;      <span class="ruby-identifier">versions</span>[<span class="ruby-value">:small</span>]  = <span class="ruby-identifier">pipeline</span>.<span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-identifier">versions</span> <span class="ruby-comment"># return the hash of processed files</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>After these files have been uploaded, their data will all be saved to the
<code>&lt;attachment&gt;_data</code> column. The attachment getter will
then read them as a Hash of <code>Shrine::UploadedFile</code> objects.</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># &#39;{</span>&#x000A;<span class="ruby-comment">#   &quot;original&quot;: {&quot;id&quot;:&quot;9sd84.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;large&quot;: {&quot;id&quot;:&quot;lg043.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;medium&quot;: {&quot;id&quot;:&quot;kd9fk.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;small&quot;: {&quot;id&quot;:&quot;932fl.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}}</span>&#x000A;<span class="ruby-comment"># }&#39;</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   :original =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;9sd84.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :large    =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;lg043.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :medium   =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;kd9fk.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :small    =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;932fl.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[<span class="ruby-value">:medium</span>]           <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[<span class="ruby-value">:medium</span>].<span class="ruby-identifier">url</span>       <span class="ruby-comment">#=&gt; &quot;/uploads/store/lg043.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[<span class="ruby-value">:medium</span>].<span class="ruby-identifier">size</span>      <span class="ruby-comment">#=&gt; 5825949</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[<span class="ruby-value">:medium</span>].<span class="ruby-identifier">mime_type</span> <span class="ruby-comment">#=&gt; &quot;image/jpeg&quot;</span></pre>

<p>The <code>versions</code> plugin also expands
<code>#&lt;attachment&gt;_url</code> to accept version names:</p>

<pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>(<span class="ruby-value">:large</span>) <span class="ruby-comment">#=&gt; &quot;https://...&quot;</span></pre>

<p>For more details, including examples of how to do custom processing, see
the <a href="https://shrinerb.com/rdoc/files/doc/processing_md.html">File
Processing</a> guide.</p>

<h2 id="label-Context">Context<span><a href="#label-Context">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The <code>#upload</code> (and <code>#delete</code>) methods accept a hash
of options as the second argument, which is forwarded to all other tasks
like processing, extracting metadata and generating location.</p>

<pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, { <span class="ruby-value">foo:</span> <span class="ruby-string">&quot;bar&quot;</span> }) <span class="ruby-comment"># context hash is forwarded to all tasks around upload</span></pre>

<p>Some options are actually recognized by <a
href="../classes/Shrine.html">Shrine</a>, like <code>:location</code> and
<code>:upload_options</code>, some are added by plugins, and the rest are
there just to provide additional context, for more flexibility in
performing tasks and more descriptive logging.</p>

<p>The attacher automatically includes additional <code>context</code>
information for each upload and delete operation:</p>
<ul><li>
<p><code>context[:record]</code> – model instance where the file is attached</p>
</li><li>
<p><code>context[:name]</code> – name of the attachment attribute on the model</p>
</li><li>
<p><code>context[:action]</code> – identifier for the action being performed
(<code>:cache</code>, <code>:store</code>, <code>:recache</code>,
<code>:backup</code>, …)</p>
</li></ul>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">process</span>(<span class="ruby-value">:store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">trim_video</span>(<span class="ruby-identifier">io</span>, <span class="ruby-value">300</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[<span class="ruby-value">:record</span>].<span class="ruby-identifier">user</span>.<span class="ruby-identifier">free_plan?</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<h2 id="label-Validation">Validation<span><a href="#label-Validation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> can perform file validations
for files assigned to the model. The validations are defined inside the
<code>Attacher.validate</code> block, and you can load the
<code>validation_helpers</code> plugin to get convenient file validation
methods:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> <span class="ruby-value">:validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">5</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>, <span class="ruby-value">message:</span> <span class="ruby-string">&quot;is too large (max is 5 MB)&quot;</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> <span class="ruby-node">%w[application/pdf]</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-identifier">user</span> = <span class="ruby-constant">User</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">cv</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;cv.pdf&quot;</span>)&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment">#=&gt; false</span>&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">to_hash</span> <span class="ruby-comment">#=&gt; {:cv=&gt;[&quot;is too large (max is 5 MB)&quot;]}</span></pre>

<p>See the <a
href="https://shrinerb.com/rdoc/files/doc/validation_md.html">File
Validation</a> guide and <code>validation_helpers</code> plugin
documentation for more details.</p>

<h2 id="label-Location">Location<span><a href="#label-Location">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Before <a href="../classes/Shrine.html">Shrine</a> uploads a file, it
generates a random location for it. By default the hierarchy is flat; all
files are stored in the root directory of the storage. The
<code>pretty_location</code> plugin provides a nice default hierarchy, but
you can also override <code>#generate_location</code> with a custom
implementation:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">generate_location</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span>)&#x000A;    <span class="ruby-identifier">type</span>  = <span class="ruby-identifier">context</span>[<span class="ruby-value">:record</span>].<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[<span class="ruby-value">:record</span>]&#x000A;    <span class="ruby-identifier">style</span> = <span class="ruby-identifier">context</span>[<span class="ruby-value">:version</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:original</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;originals&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;thumbs&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[<span class="ruby-value">:version</span>]&#x000A;    <span class="ruby-identifier">name</span>  = <span class="ruby-keyword">super</span> <span class="ruby-comment"># the default unique identifier</span>&#x000A;&#x000A;    [<span class="ruby-identifier">type</span>, <span class="ruby-identifier">style</span>, <span class="ruby-identifier">name</span>].<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;/&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre>uploads/&#x000A;  photos/&#x000A;    originals/&#x000A;      la98lda74j3g.jpg&#x000A;    thumbs/&#x000A;      95kd8kafg80a.jpg&#x000A;      ka8agiaf9gk4.jpg</pre>

<p>Note that there should always be a random component in the location, so
that the ORM dirty tracking is detected properly. Inside
<code>#generate_location</code> you can also access the extracted metadata
through <code>context[:metadata]</code>.</p>

<p>When uploading single files, it&#39;s possible to bypass
<code>#generate_location</code> via the uploader, by specifying
<code>:location</code>:</p>

<pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-value">location:</span> <span class="ruby-string">&quot;some/specific/location.mp4&quot;</span>)</pre>

<h2 id="label-Direct+uploads">Direct uploads<span><a href="#label-Direct+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>To really improve the user experience, it&#39;s recommended to start
uploading the files asynchronously as soon they&#39;re selected. This way
the UI is still responsive during upload, so the user can fill in other
fields while the files are being uploaded, and if you display a progress
bar they can see when the upload will finish.</p>

<p>The asynchronous uploads will have to go to a separate endpoint than the
one where the form is submitted. You can use Shrine&#39;s
<code>upload_endpoint</code> plugin to create a Rack app that accepts file
uploads and forwards them to the specified storage. We want to set it up to
upload to <em>temporary</em> storage (<code>:cache</code>), because
we&#39;re replacing the caching step from the default synchronous workflow.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:upload_endpoint</span></pre>

<pre class="ruby"><span class="ruby-comment"># config.ru (Rack)</span>&#x000A;<span class="ruby-identifier">map</span> <span class="ruby-string">&quot;/images/upload&quot;</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">run</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">upload_endpoint</span>(<span class="ruby-value">:cache</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># OR</span>&#x000A;&#x000A;<span class="ruby-comment"># config/routes.rb (Rails)</span>&#x000A;<span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">upload_endpoint</span>(<span class="ruby-value">:cache</span>) <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;/images/upload&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>The above will add a <code>POST /images/upload</code> route to your app.
You can now use the <strong><a href="https://uppy.io">Uppy</a></strong>
JavaScript library to upload files to this endpoint as soon they&#39;re
selected, and write the result to the hidden field. The JavaScript code for
this will depend on your application, see <a
href="https://github.com/shrinerb/shrine/wiki/Adding-Direct-App-Uploads">this
walkthrough</a> that adds direct uploads from scratch.</p>

<p>You can also upload files directly to the cloud (AWS S3, Google Cloud etc),
using Shrine&#39;s <code>presign_endpoint</code> plugin. See <a
href="https://github.com/shrinerb/shrine/wiki/Adding-Direct-S3-Uploads<Paste>“>this
walkthrough</a> that adds direct S3 uploads from scratch using Uppy, as
well as the <a
href="https://shrinerb.com/rdoc/files/doc/direct_s3_md.html">Direct Uploads
to S3</a> guide that provides some useful tips. Also check out the <a
href="https://github.com/shrinerb/shrine/tree/master/demo">Roda</a> or <a
href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a>
demo app which implements multiple uploads directly to S3.</p>

<h3 id="label-Resumable+uploads">Resumable uploads<span><a href="#label-Resumable+uploads">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When your app is dealing with large uploads (e.g. videos), keep in mind
that it can be challening for your users to upload these large files to
your app. Many users might not have a great internet connection, and if it
happens to break at any point during uploading, they would need to restart
the upload from the beginning.</p>

<p>Luckily, there is a solution for this. <strong><a
href="https://tus.io">Tus.io</a></strong> is an open protocol for resumable
file uploads, which enables the client and the server to achieve reliable
file uploads even on unstable connections, by enabling the upload to be
resumed in case of interruptions, even after the browser was closed or the
device was shut down.</p>

<p>On the client side you can use <a href="https://uppy.io/docs/tus/">Uppy</a>
with <a href="https://github.com/tus/tus-js-client">tus-js-client</a>, have
it upload files to a <a
href="https://github.com/janko-m/tus-ruby-server">tus-ruby-server</a>, and
finally attach the uploaded files with the help of <a
href="https://github.com/shrinerb/shrine-tus">shrine-tus</a>. See <a
href="https://github.com/shrinerb/shrine/wiki/Adding-Resumable-Uploads">this
walkthrough</a> that adds resumable uploads from scratch, as well as the <a
href="https://github.com/shrinerb/shrine-tus-demo">Roda demo</a> for a
complete example.</p>

<h2 id="label-Backgrounding">Backgrounding<span><a href="#label-Backgrounding">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> is the first file attachment
library designed for backgrounding support. Moving phases of managing file
attachments to background jobs is essential for scaling and good user
experience, and <a href="../classes/Shrine.html">Shrine</a> provides a
<code>backgrounding</code> plugin which makes it easy to plug in your
favourite backgrounding library:</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:backgrounding</span>&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">DeleteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }</pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">PromoteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DeleteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>The above puts promoting (uploading cached file to permanent storage) and
deleting of files for all uploaders into background jobs using Sidekiq.
Obviously instead of Sidekiq you can use <a
href="https://github.com/shrinerb/shrine/wiki/Backgrounding-libraries">any
other backgrounding library</a>.</p>

<h2 id="label-Clearing+cache">Clearing cache<span><a href="#label-Clearing+cache">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> doesn&#39;t automatically
delete files uploaded to temporary storage, instead you should set up a
separate recurring task that will automatically delete old cached files.</p>

<p>Most of <a href="../classes/Shrine.html">Shrine</a> storage classes come
with a <code>#clear!</code> method, which you can call in a recurring
script. For FileSystem and S3 storage it would look like this:</p>

<pre class="ruby"><span class="ruby-comment"># FileSystem storage</span>&#x000A;<span class="ruby-identifier">file_system</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[<span class="ruby-value">:cache</span>]&#x000A;<span class="ruby-identifier">file_system</span>.<span class="ruby-identifier">clear!</span>(<span class="ruby-value">older_than:</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span><span class="ruby-operator">*</span><span class="ruby-value">24</span><span class="ruby-operator">*</span><span class="ruby-value">60</span><span class="ruby-operator">*</span><span class="ruby-value">60</span>) <span class="ruby-comment"># delete files older than 1 week</span></pre>

<pre class="ruby"><span class="ruby-comment"># S3 storage</span>&#x000A;<span class="ruby-identifier">s3</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[<span class="ruby-value">:cache</span>]&#x000A;<span class="ruby-identifier">s3</span>.<span class="ruby-identifier">clear!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">object</span><span class="ruby-operator">|</span> <span class="ruby-identifier">object</span>.<span class="ruby-identifier">last_modified</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span><span class="ruby-operator">*</span><span class="ruby-value">24</span><span class="ruby-operator">*</span><span class="ruby-value">60</span><span class="ruby-operator">*</span><span class="ruby-value">60</span> } <span class="ruby-comment"># delete files older than 1 week</span></pre>

<p>Note that for AWS S3 you can also configure bucket lifecycle rules to do
this for you. This can be done either from the [AWS Console][S3 lifecycle
console] or via an <a
href="https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/S3/Client.html#put_bucket_lifecycle_configuration-instance_method">API
call</a>:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;aws-sdk-s3&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">client</span> = <span class="ruby-constant">Aws</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span><span class="ruby-operator">::</span><span class="ruby-constant">Client</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">access_key_id:</span>     <span class="ruby-string">&quot;&lt;YOUR KEY&gt;&quot;</span>,&#x000A;  <span class="ruby-value">secret_access_key:</span> <span class="ruby-string">&quot;&lt;YOUR SECRET&gt;&quot;</span>,&#x000A;  <span class="ruby-value">region:</span>            <span class="ruby-string">&quot;&lt;REGION&gt;&quot;</span>,&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">client</span>.<span class="ruby-identifier">put_bucket_lifecycle_configuration</span>(&#x000A;  <span class="ruby-value">bucket:</span> <span class="ruby-string">&quot;&lt;YOUR BUCKET&gt;&quot;</span>,&#x000A;  <span class="ruby-value">lifecycle_configuration:</span> {&#x000A;    <span class="ruby-value">rules:</span> [{&#x000A;      <span class="ruby-value">expiration:</span> { <span class="ruby-value">days:</span> <span class="ruby-value">7</span> },&#x000A;      <span class="ruby-value">filter:</span> { <span class="ruby-value">prefix:</span> <span class="ruby-string">&quot;cache/&quot;</span> },&#x000A;      <span class="ruby-value">id:</span> <span class="ruby-string">&quot;cache-clear&quot;</span>,&#x000A;      <span class="ruby-value">status:</span> <span class="ruby-string">&quot;Enabled&quot;</span>&#x000A;    }]&#x000A;  }&#x000A;)</pre>

<h2 id="label-Logging">Logging<span><a href="#label-Logging">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> ships with the
<code>logging</code> which automatically logs processing, uploading, and
deleting of files. This can be very helpful for debugging and performance
monitoring.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:logging</span></pre>

<pre>2015-10-09T20:06:06.676Z #25602: STORE[cache] ImageUploader[:avatar] User[29543] 1 file (0.1s)&#x000A;2015-10-09T20:06:06.854Z #25602: PROCESS[store]: ImageUploader[:avatar] User[29543] 1-3 files (0.22s)&#x000A;2015-10-09T20:06:07.133Z #25602: DELETE[destroyed]: ImageUploader[:avatar] User[29543] 3 files (0.07s)</pre>

<h2 id="label-Settings">Settings<span><a href="#label-Settings">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Each uploader can store generic settings in the <code>opts</code> hash,
which can be accessed in other uploader actions. You can store there
anything that you find convenient.</p>

<pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:type</span>] = <span class="ruby-string">&quot;file&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>; <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:type</span>] = <span class="ruby-string">&quot;image&quot;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">DocumentUploader</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:type</span>] <span class="ruby-comment">#=&gt; &quot;file&quot;</span>&#x000A;<span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:type</span>]    <span class="ruby-comment">#=&gt; &quot;image&quot;</span></pre>

<p>Because <code>opts</code> is cloned in subclasses, overriding settings
works with inheritance. The <code>opts</code> hash is used internally by
plugins to store configuration.</p>

<h2 id="label-Inspiration">Inspiration<span><a href="#label-Inspiration">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/Shrine.html">Shrine</a> was heavily inspired by <a
href="https://github.com/refile/refile">Refile</a> and <a
href="https://github.com/jeremyevans/roda">Roda</a>. From Refile it borrows
the idea of “backends” (here named “storages”), attachment interface, and
direct uploads. From Roda it borrows the implementation of an extensible
plugin system.</p>

<h2 id="label-Similar+libraries">Similar libraries<span><a href="#label-Similar+libraries">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p>Paperclip</p>
</li><li>
<p>CarrierWave</p>
</li><li>
<p>Dragonfly</p>
</li><li>
<p>Refile</p>
</li><li>
<p>Active Storage</p>
</li></ul>

<h2 id="label-Code+of+Conduct">Code of Conduct<span><a href="#label-Code+of+Conduct">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Everyone interacting in the <a href="../classes/Shrine.html">Shrine</a>
project’s codebases, issue trackers, and mailing lists is expected to
follow the <a
href="https://github.com/shrinerb/shrine/blob/master/CODE_OF_CONDUCT.md">Shrine
code of conduct</a>.</p>

<h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The gem is available as open source under the terms of the <a
href="http://opensource.org/licenses/MIT">MIT License</a>.</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
