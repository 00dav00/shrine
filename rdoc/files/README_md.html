<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>README.md</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>README.md</h1>
        <div class='paths'>
          README.md
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2017-04-04 15:16:39 +1000</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Shrine"><a href="../classes/Shrine.html">Shrine</a><span><a href="#label-Shrine">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p><a href="../classes/Shrine.html">Shrine</a> is a toolkit for file
            attachments in Ruby applications.</p>
            
            <p>If you&#39;re not sure why you should care, you&#39;re encouraged to read
            the <a
            href="https://twin.github.io/better-file-uploads-with-shrine-motivation/">motivation
            behind creating Shrine</a>.</p>
            
            <h2 id="label-Resources">Resources<span><a href="#label-Resources">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Documentation: <a target="_top" href="http://shrinerb.com">shrinerb.com</a></p>
            </li><li>
            <p>Source: <a
            href="https://github.com/janko-m/shrine">github.com/janko-m/shrine</a></p>
            </li><li>
            <p>Bugs: <a
            href="https://github.com/janko-m/shrine/issues">github.com/janko-m/shrine/issues</a></p>
            </li><li>
            <p>Help &amp; Discussion: <a
            href="https://groups.google.com/forum/#!forum/ruby-shrine">groups.google.com/group/ruby-shrine</a></p>
            </li></ul>
            
            <h2 id="label-Quick+start">Quick start<span><a href="#label-Quick+start">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Add <a href="../classes/Shrine.html">Shrine</a> to the Gemfile and write an
            initializer which sets up the storage and loads the ORM plugin:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;shrine&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine&quot;</span>&#x000A;<span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/file_system&quot;</span>&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;uploads/cache&quot;</span>), <span class="ruby-comment"># temporary</span>&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">FileSystem</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;public&quot;</span>, <span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;uploads/store&quot;</span>), <span class="ruby-comment"># permanent</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">sequel</span> <span class="ruby-comment"># or :activerecord</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">cached_attachment_data</span> <span class="ruby-comment"># for forms</span>&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rack_file</span> <span class="ruby-comment"># for non-Rails apps</span></pre>
            
            <p>Next decide how you will name the attachment attribute on your model, and
            run a migration that adds an <code>&lt;attachment&gt;_data</code> text
            column, which <a href="../classes/Shrine.html">Shrine</a> will use to store
            all information about the attachment:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>                           <span class="ruby-comment"># class AddImageDataToPhotos &lt; ActiveRecord::Migration</span>&#x000A;  <span class="ruby-identifier">change</span> <span class="ruby-keyword">do</span>                                   <span class="ruby-comment">#   def change</span>&#x000A;    <span class="ruby-identifier">add_column</span> :<span class="ruby-identifier">photos</span>, :<span class="ruby-identifier">image_data</span>, :<span class="ruby-identifier">text</span>    <span class="ruby-comment">#     add_column :photos, :image_data, :text</span>&#x000A;  <span class="ruby-keyword">end</span>                                         <span class="ruby-comment">#   end</span>&#x000A;<span class="ruby-keyword">end</span>                                           <span class="ruby-comment"># end</span></pre>
            
            <p>Now you can create an uploader class for the type of files you want to
            upload, and add a virtual attribute for handling attachments using this
            uploader to your model:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># plugins and uploading logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span> <span class="ruby-comment"># ActiveRecord::Base</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">image</span>) <span class="ruby-comment"># adds an `image` virtual attribute</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Let&#39;s now add the form fields which will use this virtual attribute. We
            need (1) a file field for choosing files, and (2) a hidden field for
            retaining the uploaded file in case of validation errors and <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">direct
            uploads</a>.</p>
            
            <pre>&lt;form action=&quot;/photos&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&#x000A;  &lt;input name=&quot;photo[image]&quot; type=&quot;hidden&quot; value=&quot;&lt;%= @photo.cached_image_data %&gt;&quot;&gt;&#x000A;  &lt;input name=&quot;photo[image]&quot; type=&quot;file&quot;&gt;&#x000A;&lt;/form&gt;&#x000A;&lt;!-- Rails: --&gt;&#x000A;&lt;%= form_for @photo do |f| %&gt;&#x000A;  &lt;%= f.hidden_field :image, value: @photo.cached_image_data %&gt;&#x000A;  &lt;%= f.file_field :image %&gt;&#x000A;&lt;% end %&gt;</pre>
            
            <p>Note that the file field needs to go <em>after</em> the hidden field, so
            that selecting a new file can always override the cached file in the hidden
            field. Also notice the <code>enctype=&quot;multipart/form-data&quot;</code>
            HTML attribute, which is required for submitting files through the form,
            though the Rails form builder will automatically generate it for you.</p>
            
            <p>Now in your router/controller the attachment request parameter can be
            assigned to the model like any other attribute:</p>
            
            <pre class="ruby"><span class="ruby-identifier">post</span> <span class="ruby-string">&quot;/photos&quot;</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">params</span>[:<span class="ruby-identifier">photo</span>])&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Once a file is uploaded and attached to the record, you can retrieve a URL
            to the uploaded file and display it:</p>
            
            <pre>&lt;img src=&quot;&lt;%= @photo.image_url %&gt;&quot;&gt;</pre>
            
            <h2 id="label-Storage">Storage<span><a href="#label-Storage">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>A “storage” in <a href="../classes/Shrine.html">Shrine</a> is an object
            responsible for managing files on a specific storage service (filesystem,
            Amazon S3 etc), which implements a generic method interface. Storages are
            configured directly and registered under a name in
            <code>Shrine.storages</code>, so that they can be later used by uploaders.</p>
            
            <pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;aws-sdk&quot;</span>, <span class="ruby-string">&quot;~&gt; 2.1&quot;</span> <span class="ruby-comment"># for Amazon S3 storage</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;shrine/storage/s3&quot;</span>&#x000A;&#x000A;<span class="ruby-identifier">s3_options</span> = {&#x000A;  <span class="ruby-identifier">access_key_id</span><span class="ruby-operator">:</span>     <span class="ruby-string">&quot;abc&quot;</span>,&#x000A;  <span class="ruby-identifier">secret_access_key</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;xyz&quot;</span>,&#x000A;  <span class="ruby-identifier">region</span><span class="ruby-operator">:</span>            <span class="ruby-string">&quot;my-region&quot;</span>,&#x000A;  <span class="ruby-identifier">bucket</span><span class="ruby-operator">:</span>            <span class="ruby-string">&quot;my-bucket&quot;</span>,&#x000A;}&#x000A;&#x000A;<span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span> = {&#x000A;  <span class="ruby-identifier">cache</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;cache&quot;</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;  <span class="ruby-identifier">store</span><span class="ruby-operator">:</span> <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Storage</span><span class="ruby-operator">::</span><span class="ruby-constant">S3</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">prefix</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;store&quot;</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">s3_options</span>),&#x000A;}</pre>
            
            <p>The above example sets up Amazon S3 storage both for temporary and
            permanent storage, which allows for <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">direct
            uploads</a>. The <code>:cache</code> and <code>:store</code> names are
            special only in terms that the attacher will automatically pick them up,
            but you can also register more than two storages under different names.</p>
            
            <p><a href="../classes/Shrine.html">Shrine</a> ships with <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/FileSystem.html">FileSystem</a>
            and <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html">S3</a>
            storage, take a look at their documentation for more details on various
            features they support. There are also <a
            href="http://shrinerb.com/#external">many more Shrine storages</a> shipping
            as external gems.</p>
            
            <h2 id="label-Uploader">Uploader<span><a href="#label-Uploader">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Uploaders are subclasses of <code>Shrine</code>, and are essentially
            wrappers around storages. In addition to actually calling the underlying
            storage when they need to, they also perform many generic tasks which
            aren&#39;t related to a particular storage (like processing, extracting
            metadata, logging etc).</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-comment"># image attachent logic</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span> = <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">store</span>)&#x000A;<span class="ruby-identifier">uploader</span> <span class="ruby-comment">#=&gt; uploader for storage registered under `:store`</span></pre>
            
            <p>It&#39;s common to create an uploader for each type of file that you want
            to handle (image, video, audio, document etc), but you can structure them
            any way that you like.</p>
            
            <h3 id="label-Uploading">Uploading<span><a href="#label-Uploading">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The main method of the uploader is <code>#upload</code>, which takes an
            IO-like object on the input, and returns a representation of the uploaded
            file on the output.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>)&#x000A;<span class="ruby-identifier">uploaded_file</span> <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></pre>
            
            <p>Some of the tasks performed by <code>#upload</code> include:</p>
            <ul><li>
            <p>file processing (if defined)</p>
            </li><li>
            <p>extracting metadata</p>
            </li><li>
            <p>generating location</p>
            </li><li>
            <p>uploading (this is where the storage is called)</p>
            </li><li>
            <p>closing the file</p>
            </li></ul>
            
            <h3 id="label-IO+abstraction">IO abstraction<span><a href="#label-IO+abstraction">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p><a href="../classes/Shrine.html">Shrine</a> is able to upload any IO-like
            object that respond to <code>#read</code>, <code>#size</code>,
            <code>#rewind</code>, <code>#eof?</code> and <code>#close</code>. This
            foremost includes all real IO objects like File, Tempfile and StringIO.</p>
            
            <p>When a file is uploaded to a Rails app, it will be represented by an
            ActionDispatch::Http::UploadedFile object in the params. This is also an
            IO-like object accepted by <a href="../classes/Shrine.html">Shrine</a>. In
            other Rack applications the uploaded file will be represented as a Hash,
            but it can still be attached when <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Plugins/RackFile.html">rack_file</a>
            plugin is loaded.</p>
            
            <p>Finally, the <code>Shrine::UploadedFile</code> object, returned by
            uploading, is itself an IO-like object. This makes it incredibly easy to
            reupload a file from one storage to another, and this is used by the
            attacher to reupload a file stored on temporary storage to permanent
            storage.</p>
            
            <h3 id="label-Deleting">Deleting<span><a href="#label-Deleting">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The uploader can also delete uploaded files via <code>#delete</code>.
            Internally this just delegates to the uploaded file, but some plugins bring
            additional behaviour (e.g. logging).</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>)&#x000A;<span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">uploaded_file</span>)</pre>
            
            <h2 id="label-Uploaded+file">Uploaded file<span><a href="#label-Uploaded+file">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The <code>Shrine::UploadedFile</code> object represents the file that was
            uploaded to the storage. It contains the following information:</p>
            <ul><li>
            <p><code>storage</code> – identifier of the storage the file was uploaded to</p>
            </li><li>
            <p><code>id</code> – the location of the file on the storage</p>
            </li><li>
            <p><code>metadata</code> – file metadata that was extracted during upload</p>
            </li></ul>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span> = <span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>)&#x000A;&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">id</span>       <span class="ruby-comment">#=&gt; &quot;949sdjg834.jpg&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">storage</span>  <span class="ruby-comment">#=&gt; #&lt;Shrine::Storage::FileSystem&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt; {...}</span>&#x000A;&#x000A;<span class="ruby-comment"># It can be serialized into JSON and saved to a database column</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">to_json</span>  <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;949sdjg834.jpg&quot;,&quot;storage&quot;:&quot;store&quot;,&quot;metadata&quot;:{...}}&#39;</span></pre>
            
            <p>It comes with many convenient methods that delegate to the storage:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">url</span>      <span class="ruby-comment">#=&gt; &quot;https://my-bucket.s3.amazonaws.com/949sdjg834.jpg&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">download</span> <span class="ruby-comment">#=&gt; #&lt;Tempfile&gt;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">exists?</span>  <span class="ruby-comment">#=&gt; true</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">open</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">io</span><span class="ruby-operator">|</span> <span class="ruby-identifier">io</span>.<span class="ruby-identifier">read</span> }&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">delete</span></pre>
            
            <p>It also implements the IO-like interface that conforms to Shrine&#39;s IO
            abstraction, which allows it to be uploaded to other storages.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">read</span>   <span class="ruby-comment"># returns content of the uploaded file</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">eof?</span>   <span class="ruby-comment"># returns true if the whole IO was read</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">rewind</span> <span class="ruby-comment"># rewinds the IO</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">close</span>  <span class="ruby-comment"># closes the IO</span></pre>
            
            <h2 id="label-Attachment">Attachment<span><a href="#label-Attachment">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Storages, uploaders, and uploaded file objects are the main components for
            managing files. Since most often you also want to <em>attach</em> the
            uploaded files to database records, <a
            href="../classes/Shrine.html">Shrine</a> comes with a high-level attachment
            interface, which uses these components internally.</p>
            
            <p>Usually you&#39;re using an ORM for saving database records, in which case
            you can load an additional plugin to automatically tie the attached files
            to record lifecycle. But you can also use <a
            href="../classes/Shrine.html">Shrine</a> just with plain models.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">sequel</span> <span class="ruby-comment"># :activerecord</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Photo</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Sequel</span><span class="ruby-operator">::</span><span class="ruby-constant">Model</span> <span class="ruby-comment"># ActiveRecord::Base</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attachment</span>.<span class="ruby-identifier">new</span>(:<span class="ruby-identifier">image</span>) <span class="ruby-comment">#</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">attachment</span>(:<span class="ruby-identifier">image</span>)      <span class="ruby-comment"># these are all equivalent</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageUploader</span>[:<span class="ruby-identifier">image</span>]                 <span class="ruby-comment">#</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can choose whichever of these three syntaxes you prefer. In any case
            this will create a <code>Shrine::Attachment</code> module with attachment
            methods for the specified attribute, which then get added to your model
            when you include it:</p>
            <ul><li>
            <p><code>#image=</code> – uploads the file to temporary storage and serializes
            the result into <code>image_data</code></p>
            </li><li>
            <p><code>#image</code> – returns <code>Shrine::UploadedFile</code>
            instantiated from <code>image_data</code></p>
            </li><li>
            <p><code>#image_url</code> – calls <code>url</code> on the attachment if
            it&#39;s present, otherwise returns nil</p>
            </li><li>
            <p><code>#image_attacher</code> – returns instance of
            <code>Shrine::Attacher</code> which handles the attaching</p>
            </li></ul>
            
            <p>The ORM plugin that we loaded adds appropriate callbacks, so when record is
            saved the attachment is uploaded to permanent storage, and when record is
            deleted the attachment is deleted as well.</p>
            
            <pre class="ruby"><span class="ruby-comment"># no file is attached</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt; nil</span>&#x000A;&#x000A;<span class="ruby-comment"># the assigned file is cached to temporary storage and written to `image_data` column</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;waterfall.jpg&quot;</span>)&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile @data={...}&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>  <span class="ruby-comment">#=&gt; &quot;/uploads/cache/0sdfllasfi842.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;0sdfllasfi842.jpg&quot;,&quot;storage&quot;:&quot;cache&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;&#x000A;<span class="ruby-comment"># the cached file is promoted to permanent storage and saved to `image_data` column</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">save</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>      <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile @data={...}&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>  <span class="ruby-comment">#=&gt; &quot;/uploads/store/l02kladf8jlda.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt; &#39;{&quot;id&quot;:&quot;l02kladf8jlda.jpg&quot;,&quot;storage&quot;:&quot;store&quot;,&quot;metadata&quot;:{...}}&#39;</span>&#x000A;&#x000A;<span class="ruby-comment"># the attached file is deleted with the record</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">destroy</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">exists?</span> <span class="ruby-comment">#=&gt; false</span></pre>
            
            <p>If there is already a file attached, and the attachment is overriden
            (either with a new file or no file), the previous attachment will get
            deleted when the record gets saved.</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-identifier">new_file</span>) <span class="ruby-comment"># changes the attachment and deletes previous</span>&#x000A;<span class="ruby-comment"># or</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-keyword">nil</span>)      <span class="ruby-comment"># removes the attachment and deletes previous</span></pre>
            
            <p>In addition to assigning raw files, you can also assign a JSON
            representation of files that are already uploaded to the temporary storage.
            This allows <a href="../classes/Shrine.html">Shrine</a> to retain cached
            files in case of validation errors, and handle <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">direct
            uploads</a>, via the hidden form field.</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> = <span class="ruby-string">&#39;{&#x000A;  &quot;id&quot;: &quot;9260ea09d8effd.jpg&quot;,&#x000A;  &quot;storage&quot;: &quot;cache&quot;,&#x000A;  &quot;metadata&quot;: { ... }&#x000A;}&#39;</span></pre>
            
            <h2 id="label-Attacher">Attacher<span><a href="#label-Attacher">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The model attachment attributes and callbacks just delegate the behaviour
            to a <code>Shrine::Attacher</code> object.</p>
            
            <pre class="ruby"><span class="ruby-identifier">attacher</span> = <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">photo</span>, :<span class="ruby-identifier">image</span>) <span class="ruby-comment"># returned by `photo.image_attacher`</span>&#x000A;&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">file</span>) <span class="ruby-comment"># equivalent to `photo.image = file`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">get</span>          <span class="ruby-comment"># equivalent to `photo.image`</span>&#x000A;<span class="ruby-identifier">attacher</span>.<span class="ruby-identifier">url</span>          <span class="ruby-comment"># equivalent to `photo.image_url`</span></pre>
            
            <p>The attacher is what drives attaching files to models, and it functions
            independently from models&#39; attachment interface. This means that you
            can use it as an alternative, in case you prefer not to add additional
            attributes to the model, or prefer explicitness over callbacks. It&#39;s
            also useful when you need something more advanced which isn&#39;t available
            through the attachment attributes.</p>
            
            <p>Whenever the attacher uploads or deletes files, it sends a
            <code>context</code> hash which includes <code>:record</code>,
            <code>:name</code>, and <code>:action</code> keys, so that you can perform
            processing or generate location differently depending on this information.
            See <a href="https://github.com/janko-m/shrine#context">Context</a> section
            for more details.</p>
            
            <p>For more information about <code>Shrine::Attacher</code>, see <a
            href="http://shrinerb.com/rdoc/files/doc/attacher_md.html">Using
            Attacher</a> guide.</p>
            
            <h2 id="label-Plugin+system">Plugin system<span><a href="#label-Plugin+system">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>By default <a href="../classes/Shrine.html">Shrine</a> comes with a small
            core which provides only the essential functionality. All additional
            features are available via <a
            href="http://shrinerb.com/#plugins">plugins</a>, which also ship with <a
            href="../classes/Shrine.html">Shrine</a>. This way you can choose exactly
            what and how much <a href="../classes/Shrine.html">Shrine</a> does for you,
            and you load the code only for features that you use.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">logging</span> <span class="ruby-comment"># adds logging</span></pre>
            
            <p>Plugins add behaviour by extending <a
            href="../classes/Shrine.html">Shrine</a> core classes via module inclusion,
            and many of them also accept configuration options. The plugin system
            respects inheritance, so you can choose to load a plugin globally or per
            uploader.</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">store_dimensions</span> <span class="ruby-comment"># extract image dimensions only for this uploader and its descendants</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Metadata">Metadata<span><a href="#label-Metadata">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> automatically extracts
            available file metadata and saves them to the
            <code>Shrine::UploadedFile</code>. You can access them through the
            <code>#metadata</code> hash or via metadata methods:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">metadata</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &quot;filename&quot; =&gt; &quot;matrix.mp4&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;mime_type&quot; =&gt; &quot;video/mp4&quot;,</span>&#x000A;<span class="ruby-comment">#   &quot;size&quot; =&gt; 345993,</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">original_filename</span> <span class="ruby-comment">#=&gt; &quot;matrix.mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">extension</span>         <span class="ruby-comment">#=&gt; &quot;mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">mime_type</span>         <span class="ruby-comment">#=&gt; &quot;video/mp4&quot;</span>&#x000A;<span class="ruby-identifier">uploaded_file</span>.<span class="ruby-identifier">size</span>              <span class="ruby-comment">#=&gt; 345993</span></pre>
            
            <h3 id="label-MIME+type">MIME type<span><a href="#label-MIME+type">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>By default “mime_type” will be inherited from <code>#content_type</code> of
            the uploaded file, which is set from the “Content-Type” request header, but
            this header is determined by the browser solely based on the file
            extension. This means that by default Shrine&#39;s “mime_type” is
            <strong>not guaranteed</strong> to hold the actual MIME type of the file.</p>
            
            <p>However, if you load the <code>determine_mime_type</code> plugin, that will
            make <a href="../classes/Shrine.html">Shrine</a> always extract the MIME
            type from <strong>file content</strong> .</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">determine_mime_type</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">File</span>.<span class="ruby-identifier">write</span>(<span class="ruby-string">&quot;image.png&quot;</span>, <span class="ruby-string">&quot;&lt;?php ... ?&gt;&quot;</span>) <span class="ruby-comment"># PHP file with a .png extension</span>&#x000A;<span class="ruby-identifier">photo</span> = <span class="ruby-constant">Photo</span>.<span class="ruby-identifier">create</span>(<span class="ruby-identifier">image</span><span class="ruby-operator">:</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;image.png&quot;</span>))&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>.<span class="ruby-identifier">mime_type</span> <span class="ruby-comment">#=&gt; &quot;text/x-php&quot;</span></pre>
            
            <p>By the default the UNIX <a target="_top" href="http://linux.die.net/man/1/file">file</a>
            utility is used, but you can also choose a different analyzer, see
            plugin&#39;s documentation for more details.</p>
            
            <h3 id="label-Custom+metadata">Custom metadata<span><a href="#label-Custom+metadata">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>In addition to the built-in metadata, you can also extract and store
            completely custom metadata with the <code>add_metadata</code> plugin. For
            example, if we&#39;re uploading videos, we could store additional
            video-specific metadata:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;streamio-ffmpeg&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">add_metadata</span>&#x000A;&#x000A;  <span class="ruby-identifier">add_metadata</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">movie</span> = <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;    { <span class="ruby-string">&quot;duration&quot;</span>   =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">duration</span>,&#x000A;      <span class="ruby-string">&quot;bitrate&quot;</span>    =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">bitrate</span>,&#x000A;      <span class="ruby-string">&quot;resolution&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">resolution</span>,&#x000A;      <span class="ruby-string">&quot;frame_rate&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">frame_rate</span> }&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">video</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;duration&quot;</span>]   <span class="ruby-comment">#=&gt; 7.5</span>&#x000A;<span class="ruby-identifier">video</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;bitrate&quot;</span>]    <span class="ruby-comment">#=&gt; 481</span>&#x000A;<span class="ruby-identifier">video</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;resolution&quot;</span>] <span class="ruby-comment">#=&gt; &quot;640x480&quot;</span>&#x000A;<span class="ruby-identifier">video</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;frame_rate&quot;</span>] <span class="ruby-comment">#=&gt; 16.72</span></pre>
            
            <h2 id="label-Processing">Processing<span><a href="#label-Processing">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>You can have <a href="../classes/Shrine.html">Shrine</a> perform file
            processing before uploading to storage. It&#39;s generally best to process
            files prior to uploading to permanent storage, because at that point the
            selected file has been succesfully validated, and this part can be moved
            into a background job.</p>
            
            <p>This promote phase is called <code>:store</code>, and we can use the
            <code>processing</code> plugin to define processing for that phase:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Now, how do we do the actual processing? Well, <a
            href="../classes/Shrine.html">Shrine</a> actually doesn&#39;t ship with any
            file processing functionality, because that is a generic problem that
            belongs in separate libraries. If the type of files you&#39;re uploading
            are images, I created the <a
            href="https://github.com/janko-m/image_processing">image_processing</a> gem
            which you can use with Shrine:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;image_processing&quot;</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;mini_magick&quot;</span>, <span class="ruby-string">&quot;&gt;= 4.3.5&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>, <span class="ruby-value">800</span>, <span class="ruby-value">800</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">cmd</span><span class="ruby-operator">|</span> <span class="ruby-identifier">cmd</span>.<span class="ruby-identifier">auto_orient</span> } <span class="ruby-comment"># orient rotated images</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Here the <code>io</code> is a cached <code>Shrine::UploadedFile</code>, so
            we need to download it to a file, since file processing tools usually work
            with files on the filesystem.</p>
            
            <p><a href="../classes/Shrine.html">Shrine</a> treats file processing as a
            functional transformation; you are given the original file, and how
            you&#39;re going to perform processing is entirely up to you, you only need
            to return the processed files at the end of the block. Then instead of
            uploading the original file, <a href="../classes/Shrine.html">Shrine</a>
            will continue to upload the files that the processing block returned.</p>
            
            <h3 id="label-Versions">Versions<span><a href="#label-Versions">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Sometimes we want to generate multiple files as the result of processing.
            If we&#39;re uploading images, we might want to store various thumbnails
            alongside the original image. If we&#39;re uploading videos, we might want
            to save screenshots or transcode the video into different formats.</p>
            
            <p>To be able to save multiple files, we just need to load the
            <code>versions</code> plugin, and then in processing block we can return a
            Hash of files. It is recommended to also load the <code>delete_raw</code>
            plugin, so that processed files are automatically deleted after uploading.</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;image_processing/mini_magick&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">ImageProcessing</span><span class="ruby-operator">::</span><span class="ruby-constant">MiniMagick</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">versions</span>   <span class="ruby-comment"># enable Shrine to handle a hash of files</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">delete_raw</span> <span class="ruby-comment"># delete processed files after uploading</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">original</span> = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>&#x000A;&#x000A;    <span class="ruby-identifier">size_800</span> = <span class="ruby-identifier">resize_to_limit!</span>(<span class="ruby-identifier">original</span>, <span class="ruby-value">800</span>, <span class="ruby-value">800</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">cmd</span><span class="ruby-operator">|</span> <span class="ruby-identifier">cmd</span>.<span class="ruby-identifier">auto_orient</span> } <span class="ruby-comment"># orient rotated images</span>&#x000A;    <span class="ruby-identifier">size_500</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_800</span>,  <span class="ruby-value">500</span>, <span class="ruby-value">500</span>)&#x000A;    <span class="ruby-identifier">size_300</span> = <span class="ruby-identifier">resize_to_limit</span>(<span class="ruby-identifier">size_500</span>,  <span class="ruby-value">300</span>, <span class="ruby-value">300</span>)&#x000A;&#x000A;    {<span class="ruby-identifier">original</span><span class="ruby-operator">:</span> <span class="ruby-identifier">io</span>, <span class="ruby-identifier">large</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_800</span>, <span class="ruby-identifier">medium</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_500</span>, <span class="ruby-identifier">small</span><span class="ruby-operator">:</span> <span class="ruby-identifier">size_300</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>After these files have been uploaded, their data will all be saved to the
            <code>&lt;attachment&gt;_data</code> column. The attachment getter will
            then read them as a Hash of <code>Shrine::UploadedFile</code> objects.</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_data</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># &#39;{</span>&#x000A;<span class="ruby-comment">#   &quot;original&quot;: {&quot;id&quot;:&quot;9sd84.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;large&quot;: {&quot;id&quot;:&quot;lg043.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;medium&quot;: {&quot;id&quot;:&quot;kd9fk.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}},</span>&#x000A;<span class="ruby-comment">#   &quot;small&quot;: {&quot;id&quot;:&quot;932fl.jpg&quot;, &quot;storage&quot;:&quot;store&quot;, &quot;metadata&quot;:{...}}</span>&#x000A;<span class="ruby-comment"># }&#39;</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span> <span class="ruby-comment">#=&gt;</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   :original =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;9sd84.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :large    =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;lg043.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :medium   =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;kd9fk.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment">#   :small    =&gt; #&lt;Shrine::UploadedFile @data={&quot;id&quot;=&gt;&quot;932fl.jpg&quot;, ...}&gt;,</span>&#x000A;<span class="ruby-comment"># }</span>&#x000A;&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">medium</span>]           <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">medium</span>].<span class="ruby-identifier">url</span>       <span class="ruby-comment">#=&gt; &quot;/uploads/store/lg043.jpg&quot;</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">medium</span>].<span class="ruby-identifier">size</span>      <span class="ruby-comment">#=&gt; 5825949</span>&#x000A;<span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image</span>[:<span class="ruby-identifier">medium</span>].<span class="ruby-identifier">mime_type</span> <span class="ruby-comment">#=&gt; &quot;image/jpeg&quot;</span></pre>
            
            <p>The <code>versions</code> plugin also expands
            <code>#&lt;attachment&gt;_url</code> to accept version names:</p>
            
            <pre class="ruby"><span class="ruby-identifier">photo</span>.<span class="ruby-identifier">image_url</span>(:<span class="ruby-identifier">large</span>) <span class="ruby-comment">#=&gt; &quot;...&quot;</span></pre>
            
            <h3 id="label-Custom+processing">Custom processing<span><a href="#label-Custom+processing">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Your processing tool doesn&#39;t have to be in any way designed for <a
            href="../classes/Shrine.html">Shrine</a> (<a
            href="https://github.com/janko-m/image_processing">image_processing</a>
            that we saw earlier is a generic library), the only thing that you need to
            do is return processed files as some kind of IO objects. Here is an example
            of transcoding a video using <a
            href="https://github.com/streamio/streamio-ffmpeg">ffmpeg</a>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&quot;streamio-ffmpeg&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">processing</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">versions</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">delete_raw</span>&#x000A;&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">mov</span>        = <span class="ruby-identifier">io</span>.<span class="ruby-identifier">download</span>&#x000A;    <span class="ruby-identifier">video</span>      = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;video&quot;</span>, <span class="ruby-string">&quot;.mp4&quot;</span>], <span class="ruby-identifier">binmode</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)&#x000A;    <span class="ruby-identifier">screenshot</span> = <span class="ruby-constant">Tempfile</span>.<span class="ruby-identifier">new</span>([<span class="ruby-string">&quot;screenshot&quot;</span>, <span class="ruby-string">&quot;.jpg&quot;</span>], <span class="ruby-identifier">binmode</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>)&#x000A;&#x000A;    <span class="ruby-identifier">movie</span> = <span class="ruby-constant">FFMPEG</span><span class="ruby-operator">::</span><span class="ruby-constant">Movie</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">mov</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">transcode</span>(<span class="ruby-identifier">video</span>.<span class="ruby-identifier">path</span>)&#x000A;    <span class="ruby-identifier">movie</span>.<span class="ruby-identifier">screenshot</span>(<span class="ruby-identifier">screenshot</span>.<span class="ruby-identifier">path</span>)&#x000A;&#x000A;    <span class="ruby-identifier">mov</span>.<span class="ruby-identifier">delete</span>&#x000A;&#x000A;    {<span class="ruby-identifier">video</span><span class="ruby-operator">:</span> <span class="ruby-identifier">video</span>, <span class="ruby-identifier">screenshot</span><span class="ruby-operator">:</span> <span class="ruby-identifier">screenshot</span>}&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Context">Context<span><a href="#label-Context">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The <code>#upload</code> (and <code>#delete</code>) methods accept a hash
            of options as the second argument, which is forwarded to all other tasks
            like processing, extracting metadata and generating location.</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, {<span class="ruby-identifier">foo</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;bar&quot;</span>}) <span class="ruby-comment"># context hash is forwarded to all tasks around upload</span></pre>
            
            <p>Some options are actually recognized by <a
            href="../classes/Shrine.html">Shrine</a>, like <code>:location</code> and
            <code>:upload_options</code>, and some are added by plugins. However, most
            options are there just to provide you context, for more flexibility in
            performing tasks and better logging.</p>
            
            <p>The attacher automatically includes additional <code>context</code>
            information for each upload and delete:</p>
            <ul><li>
            <p><code>context[:record]</code> – model instance where the file is attached</p>
            </li><li>
            <p><code>context[:name]</code> – name of the attachment attribute on the model</p>
            </li><li>
            <p><code>context[:action]</code> – identifier for the action being performed
            (<code>:cache</code>, <code>:store</code>, <code>:recache</code>,
            <code>:backup</code>, …)</p>
            </li></ul>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">VideoUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">process</span>(:<span class="ruby-identifier">store</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">trim_video</span>(<span class="ruby-identifier">io</span>, <span class="ruby-value">300</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">record</span>].<span class="ruby-identifier">user</span>.<span class="ruby-identifier">free_plan?</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Validation">Validation<span><a href="#label-Validation">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> can perform file validations
            for files assigned to the model. The validations are registered inside a
            <code>Attacher.validate</code> block, and you can load the
            <code>validation_helpers</code> plugin to get convenient file validation
            methods:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">validation_helpers</span>&#x000A;&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">validate_max_size</span> <span class="ruby-value">5</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span><span class="ruby-operator">*</span><span class="ruby-value">1024</span>, <span class="ruby-identifier">message</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;is too large (max is 5 MB)&quot;</span>&#x000A;    <span class="ruby-identifier">validate_mime_type_inclusion</span> <span class="ruby-node">%w[application/pdf]</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-identifier">user</span> = <span class="ruby-constant">User</span>.<span class="ruby-identifier">new</span>&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">cv</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;cv.pdf&quot;</span>)&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">valid?</span> <span class="ruby-comment">#=&gt; false</span>&#x000A;<span class="ruby-identifier">user</span>.<span class="ruby-identifier">errors</span>.<span class="ruby-identifier">to_hash</span> <span class="ruby-comment">#=&gt; {cv: [&quot;is too large (max is 5 MB)&quot;]}</span></pre>
            
            <p>You can also do custom validations:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">errors</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&quot;has more than 3 pages&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">get</span>.<span class="ruby-identifier">metadata</span>[<span class="ruby-string">&quot;pages&quot;</span>] <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>When file validations fail, <a href="../classes/Shrine.html">Shrine</a>
            will by default keep the invalid cached file assigned to the model
            instance. If you want the invalid file to be deassigned, you can load the
            <code>remove_invalid</code> plugin.</p>
            
            <p>The <code>Attacher.validate</code> block is executed in context of a
            <code>Shrine::Attacher</code> instance:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">validate</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-keyword">self</span>   <span class="ruby-comment">#=&gt; #&lt;Shrine::Attacher&gt;</span>&#x000A;&#x000A;    <span class="ruby-identifier">get</span>    <span class="ruby-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span>&#x000A;    <span class="ruby-identifier">record</span> <span class="ruby-comment">#=&gt; #&lt;User&gt;</span>&#x000A;    <span class="ruby-identifier">name</span>   <span class="ruby-comment">#=&gt; :cv</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Location">Location<span><a href="#label-Location">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Before <a href="../classes/Shrine.html">Shrine</a> uploads a file, it
            generates a random location for it. By default the hierarchy is flat; all
            files are stored in the root directory of the storage. You can change how
            the location is generated by overriding <code>#generate_location</code>:</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">generate_location</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">context</span>)&#x000A;    <span class="ruby-identifier">type</span>  = <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">record</span>].<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">record</span>]&#x000A;    <span class="ruby-identifier">style</span> = <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">version</span>] <span class="ruby-operator">==</span> :<span class="ruby-identifier">original</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;originals&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;thumbs&quot;</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">context</span>[:<span class="ruby-identifier">version</span>]&#x000A;    <span class="ruby-identifier">name</span>  = <span class="ruby-keyword">super</span> <span class="ruby-comment"># the default unique identifier</span>&#x000A;&#x000A;    [<span class="ruby-identifier">type</span>, <span class="ruby-identifier">style</span>, <span class="ruby-identifier">name</span>].<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;/&quot;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre>uploads/&#x000A;  photos/&#x000A;    originals/&#x000A;      la98lda74j3g.jpg&#x000A;    thumbs/&#x000A;      95kd8kafg80a.jpg&#x000A;      ka8agiaf9gk4.jpg</pre>
            
            <p>Note that there should always be a random component in the location, so
            that any ORM dirty tracking is detected properly. Inside
            <code>#generate_location</code> you can also access the extracted metadata
            through <code>context[:metadata]</code>.</p>
            
            <p>When uploading single files, it&#39;s possible to bypass
            <code>#generate_location</code> via the uploader, by specifying
            <code>:location</code>:</p>
            
            <pre class="ruby"><span class="ruby-identifier">uploader</span>.<span class="ruby-identifier">upload</span>(<span class="ruby-identifier">file</span>, <span class="ruby-identifier">location</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;some/specific/location.mp4&quot;</span>)</pre>
            
            <h2 id="label-Direct+uploads">Direct uploads<span><a href="#label-Direct+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> comes with a
            <code>direct_upload</code> plugin that can be used for client-side
            asynchronous uploads to your app or an external service like Amazon S3. It
            provides a <a href="https://github.com/jeremyevans/roda">Roda</a> app which
            you can mount in your app:</p>
            
            <pre class="ruby"><span class="ruby-comment"># Gemfile</span>&#x000A;<span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;roda&quot;</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">direct_upload</span></pre>
            
            <pre class="ruby"><span class="ruby-constant">Rails</span>.<span class="ruby-identifier">application</span>.<span class="ruby-identifier">routes</span>.<span class="ruby-identifier">draw</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">mount</span> <span class="ruby-constant">ImageUploader</span><span class="ruby-operator">::</span><span class="ruby-constant">UploadEndpoint</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">&quot;/images&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The above setup will provide the following endpoints:</p>
            <ul><li>
            <p><code>POST /images/cache/upload</code> - for direct uploads to your app</p>
            </li><li>
            <p><code>GET /images/cache/presign</code> - for direct uploads to external
            service (e.g. Amazon S3)</p>
            </li></ul>
            
            <p>Now when the user selects a file, the client can immediately start
            uploading the file asynchronously using one of these endpoints. The JSON
            data of the uploaded file can then be written to the hidden attachment
            field, and submitted instead of the file. For JavaScript you can use
            generic file upload libraries like <a
            href="https://github.com/blueimp/jQuery-File-Upload">jQuery-File-Upload</a>,
            <a href="https://github.com/enyo/dropzone">Dropzone</a> or <a
            href="https://github.com/FineUploader/fine-uploader">FineUploader</a>.</p>
            
            <p>See the <a
            href="http://shrinerb.com/rdoc/classes/Shrine/Plugins/DirectUpload.html">direct_upload</a>
            plugin documentation and <a
            href="http://shrinerb.com/rdoc/files/doc/direct_s3_md.html">Direct Uploads
            to S3</a> guide for more details, as well as the <a
            href="https://github.com/janko-m/shrine/tree/master/demo">Roda</a> and <a
            href="https://github.com/erikdahlstrand/shrine-rails-example">Rails</a>
            demo apps which implement multiple uploads directly to S3.</p>
            
            <h2 id="label-Backgrounding">Backgrounding<span><a href="#label-Backgrounding">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> is the first file attachment
            library designed for backgrounding support. Moving phases of managing file
            attachments to background jobs is essential for scaling and good user
            experience, and <a href="../classes/Shrine.html">Shrine</a> provides a
            <code>backgrounding</code> plugin which makes it easy to plug in your
            favourite backgrounding library:</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">backgrounding</span>&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">PromoteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }&#x000A;<span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">data</span><span class="ruby-operator">|</span> <span class="ruby-constant">DeleteJob</span>.<span class="ruby-identifier">perform_async</span>(<span class="ruby-identifier">data</span>) }</pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">PromoteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">promote</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">DeleteJob</span>&#x000A;  <span class="ruby-identifier">include</span> <span class="ruby-constant">Sidekiq</span><span class="ruby-operator">::</span><span class="ruby-constant">Worker</span>&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier">perform</span>(<span class="ruby-identifier">data</span>)&#x000A;    <span class="ruby-constant">Shrine</span><span class="ruby-operator">::</span><span class="ruby-constant">Attacher</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">data</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The above puts all promoting (uploading cached file to permanent storage)
            and deleting of files into background jobs using Sidekiq. Obviously instead
            of Sidekiq you can use <a
            href="https://github.com/janko-m/shrine/wiki/Backgrounding-libraries">any
            other backgrounding library</a>.</p>
            
            <p>The main advantages of Shrine&#39;s backgrounding support over other file
            attachment libraries are:</p>
            <ul><li>
            <p><strong>User experience</strong> – Before starting the background job, <a
            href="../classes/Shrine.html">Shrine</a> will save the  record with the
            cached attachment so that it can be immediately shown to the  user. With
            other file upload libraries users cannot see the file until the  background
            job has finished.</p>
            </li><li>
            <p><strong>Simplicity</strong> – Instead of shipping with workers for you, <a
            href="../classes/Shrine.html">Shrine</a> allows you  to write your own
            workers and plug them in very easily. And no extra  columns are required.</p>
            </li><li>
            <p><strong>Generality</strong> – This setup will automatically be used for all
            uploaders,  types of files and models.</p>
            </li><li>
            <p><strong>Safety</strong> – All of Shrine&#39;s features have been designed
            to take delayed  storing into account, and concurrent requests are handled
            as well.</p>
            </li></ul>
            
            <h2 id="label-Clearing+cache">Clearing cache<span><a href="#label-Clearing+cache">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>From time to time you&#39;ll want to clean your temporary storage from old
            files. Amazon S3 provides <a
            href="http://docs.aws.amazon.com/AmazonS3/latest/UG/lifecycle-configuration-bucket-no-versioning.html">a
            built-in solution</a>, and for FileSystem you can run something like this
            periodically:</p>
            
            <pre class="ruby"><span class="ruby-identifier">file_system</span> = <span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">storages</span>[:<span class="ruby-identifier">cache</span>]&#x000A;<span class="ruby-identifier">file_system</span>.<span class="ruby-identifier">clear!</span>(<span class="ruby-identifier">older_than</span><span class="ruby-operator">:</span> <span class="ruby-constant">Time</span>.<span class="ruby-identifier">now</span> <span class="ruby-operator">-</span> <span class="ruby-value">7</span><span class="ruby-operator">*</span><span class="ruby-value">24</span><span class="ruby-operator">*</span><span class="ruby-value">60</span><span class="ruby-operator">*</span><span class="ruby-value">60</span>) <span class="ruby-comment"># delete files older than 1 week</span></pre>
            
            <h2 id="label-Logging">Logging<span><a href="#label-Logging">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> ships with the
            <code>logging</code> which automatically logs processing, uploading, and
            deleting of files. This can be very helpful for debugging and performance
            monitoring.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">logging</span></pre>
            
            <pre>2015-10-09T20:06:06.676Z #25602: STORE[cache] ImageUploader[:avatar] User[29543] 1 file (0.1s)&#x000A;2015-10-09T20:06:06.854Z #25602: PROCESS[store]: ImageUploader[:avatar] User[29543] 1-3 files (0.22s)&#x000A;2015-10-09T20:06:07.133Z #25602: DELETE[destroyed]: ImageUploader[:avatar] User[29543] 3 files (0.07s)</pre>
            
            <h2 id="label-Settings">Settings<span><a href="#label-Settings">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Each uploader can store generic settings in the <code>opts</code> hash,
            which can be accessed in other uploader actions. You can store there
            anything that you find convenient.</p>
            
            <pre class="ruby"><span class="ruby-constant">Shrine</span>.<span class="ruby-identifier">opts</span>[:<span class="ruby-identifier">type</span>] = <span class="ruby-string">&quot;file&quot;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">DocumentUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>; <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">ImageUploader</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Shrine</span>&#x000A;  <span class="ruby-identifier">opts</span>[:<span class="ruby-identifier">type</span>] = <span class="ruby-string">&quot;image&quot;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-constant">DocumentUploader</span>.<span class="ruby-identifier">opts</span>[:<span class="ruby-identifier">type</span>] <span class="ruby-comment">#=&gt; &quot;file&quot;</span>&#x000A;<span class="ruby-constant">ImageUploader</span>.<span class="ruby-identifier">opts</span>[:<span class="ruby-identifier">type</span>]    <span class="ruby-comment">#=&gt; &quot;image&quot;</span></pre>
            
            <p>Because <code>opts</code> is cloned in subclasses, overriding settings
            works with inheritance. The <code>opts</code> hash is used internally by
            plugins to store configuration.</p>
            
            <h2 id="label-On-the-fly+processing">On-the-fly processing<span><a href="#label-On-the-fly+processing">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> allows you to define processing
            that will be performed on upload. However, what if you want to have
            processing performed on-the-fly when the URL is requested? Unlike Refile or
            Dragonfly, <a href="../classes/Shrine.html">Shrine</a> doesn&#39;t come
            with an image server built in; instead it expects you to integrate any of
            the existing generic image servers.</p>
            
            <p><a href="../classes/Shrine.html">Shrine</a> has integrations for many
            commercial on-the-fly processing services, including <a
            href="https://github.com/janko-m/shrine-cloudinary">Cloudinary</a>, <a
            href="https://github.com/janko-m/shrine-imgix">Imgix</a> and <a
            href="https://github.com/janko-m/shrine-uploadcare">Uploadcare</a>.</p>
            
            <p>If you don&#39;t want to use a commercial service, <a
            href="https://github.com/choonkeat/attache">Attache</a> and <a
            href="http://markevans.github.io/dragonfly/">Dragonfly</a> are great
            open-source image servers. For Attache a <a
            href="../classes/Shrine.html">Shrine</a> integration is in progress, while
            for Dragonfly it is not needed.</p>
            
            <h2 id="label-Chunked+-26+Resumable+uploads">Chunked &amp; Resumable uploads<span><a href="#label-Chunked+-26+Resumable+uploads">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>When you&#39;re accepting large file uploads, you normally want to split it
            into multiple chunks. This way if an upload fails, it is just for one chunk
            and can be retried, while the previous chunks remain uploaded.</p>
            
            <p><a target="_top" href="http://tus.io">Tus</a> is an open protocol for resumable file
            uploads, which enables the client and the server to achieve reliable file
            uploads, even on unstable networks, with the possibility to resume the
            upload even after the browser is closed or the device are shut down. You
            can use a client library like <a
            href="https://github.com/tus/tus-js-client">tus-js-client</a> to upload the
            file to <a
            href="https://github.com/janko-m/tus-ruby-server">tus-ruby-server</a>, and
            attach the uploaded file to a record using <a
            href="https://github.com/janko-m/shrine-url">shrine-url</a>. See <a
            href="https://github.com/janko-m/shrine-tus-demo">shrine-tus-demo</a> for
            an example of complete implementation.</p>
            
            <p>Another option might be to do chunked uploads directly to your storage
            service, if the storage service supports it (e.g. Amazon S3 or Google Cloud
            Storage).</p>
            
            <h2 id="label-Inspiration">Inspiration<span><a href="#label-Inspiration">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p><a href="../classes/Shrine.html">Shrine</a> was heavily inspired by <a
            href="https://github.com/refile/refile">Refile</a> and <a
            href="https://github.com/jeremyevans/roda">Roda</a>. From Refile it borrows
            the idea of “backends” (here named “storages”), attachment interface, and
            direct uploads. From Roda it borrows the implementation of an extensible
            plugin system.</p>
            
            <h2 id="label-Similar+libraries">Similar libraries<span><a href="#label-Similar+libraries">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Paperclip</p>
            </li><li>
            <p>CarrierWave</p>
            </li><li>
            <p>Dragonfly</p>
            </li><li>
            <p>Refile</p>
            </li></ul>
            
            <h2 id="label-Code+of+Conduct">Code of Conduct<span><a href="#label-Code+of+Conduct">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Everyone interacting in the <a href="../classes/Shrine.html">Shrine</a>
            project’s codebases, issue trackers, and mailing lists is expected to
            follow the <a
            href="https://github.com/janko-m/shrine/blob/master/CODE_OF_CONDUCT.md">Shrine
            code of conduct</a>.</p>
            
            <h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The gem is available as open source under the terms of the <a
            href="http://opensource.org/licenses/MIT">MIT License</a>.</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
